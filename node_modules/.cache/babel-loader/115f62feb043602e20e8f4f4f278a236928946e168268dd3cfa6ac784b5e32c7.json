{"ast":null,"code":"import{supabase}from'../lib/supabase';import{sanitizeFilename,generateSecureId,validateFile as securityValidateFile}from'../utils/security';class SupabaseStorageService{/**\n   * Validate file before upload with enhanced security\n   * @param {File} file - File to validate\n   * @returns {Object} {isValid: boolean, error?: string}\n   */static validateFile(file){// Check file extension first (more reliable than MIME type)\nconst fileExtension='.'+file.name.split('.').pop().toLowerCase();const hasValidExtension=this.allowedExtensions.includes(fileExtension);// Check MIME type (can be unreliable, so we're more lenient)\nconst hasValidMimeType=!file.type||file.type===''||this.allowedTypes.includes(file.type)||this.allowedTypes.includes('application/octet-stream');// Fallback for unknown types\n// If extension is valid but MIME type isn't recognized, still allow it\nif(hasValidExtension&&!hasValidMimeType){console.log(\"File \".concat(file.name,\" has valid extension but unrecognized MIME type: \").concat(file.type));// Allow the file since extension is correct\n}else{// Use security utility for comprehensive validation\nconst securityValidation=securityValidateFile(file,{maxSize:this.maxFileSize,allowedTypes:this.allowedTypes,allowedExtensions:this.allowedExtensions});if(!securityValidation.isValid&&!hasValidExtension){return{isValid:false,error:securityValidation.errors[0]||'File validation failed'};}}// Additional checks for file name\nif(file.name.length>255){return{isValid:false,error:'File name is too long'};}// Check for double extensions (potential bypass attempt)\nconst doubleExtPattern=/\\.[a-z]+\\.[a-z]+$/i;if(doubleExtPattern.test(file.name)){return{isValid:false,error:'File names with double extensions are not allowed'};}return{isValid:true};}/**\n   * Generate organized file path with folder structure preservation\n   * @param {string} formType - Type of form (3d-request, 3d-quote, takeoff-request, takeoff-quote)\n   * @param {string} companyName - Company name\n   * @param {string} projectName - Project name\n   * @param {string} originalFilename - Original file name\n   * @param {string} relativePath - Relative path from folder upload (optional)\n   * @param {string} uploadSessionId - Shared session ID for folder uploads (optional)\n   * @param {boolean} preserveExactStructure - Whether to preserve exact folder structure\n   * @returns {string} File path\n   */static generateFilePath(formType,companyName,projectName,originalFilename){let relativePath=arguments.length>4&&arguments[4]!==undefined?arguments[4]:null;let uploadSessionId=arguments.length>5&&arguments[5]!==undefined?arguments[5]:null;let preserveExactStructure=arguments.length>6&&arguments[6]!==undefined?arguments[6]:true;const timestamp=new Date().toISOString().split('T')[0];const sanitizedCompany=sanitizeFilename(companyName).substring(0,50);// Limit company name length\nconst sanitizedProject=sanitizeFilename(projectName).substring(0,50);// If we have a relative path (from folder upload), preserve the folder structure\nif(relativePath&&relativePath!==originalFilename){// For folder uploads, preserve the exact structure\nif(preserveExactStructure){// Keep the original folder structure intact\n// Just sanitize each part of the path\nconst pathParts=relativePath.split('/');const sanitizedParts=pathParts.map(part=>sanitizeFilename(part));const sanitizedRelativePath=sanitizedParts.join('/');// Create a cleaner structure without redundant timestamps for each file\n// Format: formType/company/project/original_folder_structure\nconst projectFolder=sanitizedProject||'misc';return\"\".concat(formType,\"/\").concat(sanitizedCompany,\"/\").concat(projectFolder,\"/\").concat(sanitizedRelativePath);}else{// Legacy behavior with session ID\nif(!uploadSessionId){uploadSessionId=generateSecureId(12);}const pathParts=relativePath.split('/');const sanitizedParts=pathParts.map(part=>sanitizeFilename(part));const sanitizedRelativePath=sanitizedParts.join('/');return\"\".concat(formType,\"/\").concat(sanitizedCompany,\"/\").concat(timestamp,\"_\").concat(uploadSessionId,\"/\").concat(sanitizedRelativePath);}}else{// Single file upload - use secure ID\nconst fileId=uploadSessionId||generateSecureId(12);const sanitizedOriginalFilename=sanitizeFilename(originalFilename);// For single files, put them in a project folder if specified\nif(sanitizedProject&&preserveExactStructure){const projectFolder=sanitizedProject;return\"\".concat(formType,\"/\").concat(sanitizedCompany,\"/\").concat(projectFolder,\"/\").concat(sanitizedOriginalFilename);}else{// Legacy behavior\nconst filename=\"\".concat(timestamp,\"_\").concat(fileId,\"_\").concat(sanitizedOriginalFilename);return\"\".concat(formType,\"/\").concat(sanitizedCompany,\"/\").concat(filename);}}}/**\n   * Upload a single file to Supabase Storage\n   * @param {File} file - File to upload\n   * @param {string} formType - Type of form\n   * @param {string} companyName - Company name\n   * @param {string} projectName - Project name\n   * @param {Function} onProgress - Progress callback (0-100)\n   * @param {string} relativePath - Relative path for folder structure (optional)\n   * @param {string} uploadSessionId - Shared session ID for folder uploads (optional)\n   * @param {AbortSignal} signal - AbortSignal for cancellation support\n   * @param {string} sessionId - Session ID for security tracking\n   * @param {string} userId - User ID for RLS policies (optional)\n   * @returns {Promise<Object>} File metadata or error\n   */static async uploadFile(file,formType,companyName,projectName,onProgress){let relativePath=arguments.length>5&&arguments[5]!==undefined?arguments[5]:null;let uploadSessionId=arguments.length>6&&arguments[6]!==undefined?arguments[6]:null;let signal=arguments.length>7&&arguments[7]!==undefined?arguments[7]:null;let sessionId=arguments.length>8&&arguments[8]!==undefined?arguments[8]:null;let userId=arguments.length>9&&arguments[9]!==undefined?arguments[9]:null;// Declare progress variables outside try block for proper scope\nlet progressInterval=null;let currentProgress=0;try{// Validate file\nconst validation=this.validateFile(file);if(!validation.isValid){throw new Error(validation.error);}// Generate file path\nconst filePath=this.generateFilePath(formType,companyName,projectName,file.name,relativePath,uploadSessionId);// Start progress simulation since Supabase doesn't provide real progress\nif(onProgress){onProgress(5);currentProgress=5;// Simulate gradual progress during upload\nprogressInterval=setInterval(()=>{if(currentProgress<90){currentProgress+=Math.random()*3;// Increment by 0-3%\ncurrentProgress=Math.min(currentProgress,90);// Cap at 90%\nonProgress(Math.floor(currentProgress));}},500);// Update every 500ms\n}// Upload file to public bucket with optional abort signal and metadata\nconst uploadOptions={cacheControl:'3600',upsert:false};// Add metadata for RLS policies\nconst uploadMetadata={};if(sessionId){uploadMetadata.session_id=sessionId;}if(userId){uploadMetadata.user_id=userId;}if(Object.keys(uploadMetadata).length>0){uploadOptions.metadata=uploadMetadata;}// Add abort signal if provided\nif(signal){uploadOptions.signal=signal;}const{data,error}=await supabase.storage.from(this.bucketName).upload(filePath,file,uploadOptions);// Clear the progress interval\nif(progressInterval){clearInterval(progressInterval);}if(error){console.error('Supabase upload error:',error);throw new Error(\"Upload failed: \".concat(error.message));}if(onProgress){onProgress(95);await new Promise(resolve=>setTimeout(resolve,100));}// Get public URL\nconst{data:urlData}=supabase.storage.from(this.bucketName).getPublicUrl(filePath);const publicUrl=urlData===null||urlData===void 0?void 0:urlData.publicUrl;if(!publicUrl){throw new Error('Failed to generate public URL');}if(onProgress){onProgress(100);}// Return file metadata with secure ID\nconst fileMetadata={id:generateSecureId(16),filename:file.name,url:publicUrl,size:file.size,type:file.type,uploadDate:new Date().toISOString(),path:filePath,relativePath:relativePath||file.name,folder:relativePath?relativePath.split('/').slice(0,-1).join('/'):''};// Add session ID if provided for security tracking\nif(sessionId){fileMetadata.session_id=sessionId;}// Add user ID if provided for RLS policies\nif(userId){fileMetadata.user_id=userId;}return fileMetadata;}catch(error){// Clear the progress interval if it exists\nif(progressInterval){clearInterval(progressInterval);}console.error('Upload error:',error);throw error;}}/**\n   * Upload multiple files (including folder structures)\n   * @param {Array} processedFiles - Array of file objects with metadata from FolderUploadComponent\n   * @param {string} formType - Type of form\n   * @param {string} companyName - Company name\n   * @param {string} projectName - Project name\n   * @param {Function} onProgress - Progress callback per file\n   * @param {string} userId - User ID for RLS policies (optional)\n   * @returns {Promise<Object>} {successful: Array, failed: Array}\n   */static async uploadProcessedFiles(processedFiles,formType,companyName,projectName,onProgress){let userId=arguments.length>5&&arguments[5]!==undefined?arguments[5]:null;// Generate secure session ID for all files in this upload batch\nconst sessionId=generateSecureId(12);const uploadPromises=[];// Filter out invalid files\nconst validFiles=processedFiles.filter(fileObj=>fileObj.isValid.valid);const invalidFiles=processedFiles.filter(fileObj=>!fileObj.isValid.valid);for(let i=0;i<validFiles.length;i++){const fileObj=validFiles[i];uploadPromises.push(this.uploadFile(fileObj.file,formType,companyName,projectName,progress=>{if(onProgress){onProgress(i,progress,fileObj.name);}},fileObj.relativePath,sessionId,// Pass the same sessionId to all files\nnull,// signal\nsessionId,// sessionId for metadata\nuserId// userId for RLS policies\n));}try{const results=await Promise.allSettled(uploadPromises);const successful=[];const failed=[...invalidFiles.map(fileObj=>({filename:fileObj.name,error:fileObj.isValid.error}))];results.forEach((result,index)=>{if(result.status==='fulfilled'){successful.push(result.value);}else{failed.push({filename:validFiles[index].name,error:result.reason.message||'Upload failed'});}});return{successful,failed};}catch(error){console.error('Multiple upload error:',error);throw error;}}/**\n   * Upload multiple files (legacy method for backward compatibility)\n   * @param {FileList|Array} files - Files to upload\n   * @param {string} formType - Type of form\n   * @param {string} companyName - Company name\n   * @param {string} projectName - Project name\n   * @param {Function} onProgress - Progress callback per file\n   * @param {string} userId - User ID for RLS policies (optional)\n   * @returns {Promise<Array>} Array of file metadata\n   */static async uploadMultipleFiles(files,formType,companyName,projectName,onProgress){let userId=arguments.length>5&&arguments[5]!==undefined?arguments[5]:null;// Generate secure session ID for all files in this upload batch\nconst sessionId=generateSecureId(12);const uploadPromises=[];const fileArray=Array.from(files);for(let i=0;i<fileArray.length;i++){const file=fileArray[i];const relativePath=file.webkitRelativePath||file.name;uploadPromises.push(this.uploadFile(file,formType,companyName,projectName,progress=>{if(onProgress){onProgress(i,progress,file.name);}},relativePath,sessionId,// Pass the same sessionId to all files\nnull,// signal\nsessionId,// sessionId for metadata\nuserId// userId for RLS policies\n));}try{const results=await Promise.allSettled(uploadPromises);const successful=[];const failed=[];results.forEach((result,index)=>{if(result.status==='fulfilled'){successful.push(result.value);}else{failed.push({filename:fileArray[index].name,error:result.reason.message||'Upload failed'});}});return{successful,failed};}catch(error){console.error('Multiple upload error:',error);throw error;}}/**\n   * Delete a file from storage\n   * @param {string} filePath - Path to file in storage\n   * @param {string} sessionId - Session ID for security verification (optional)\n   * @returns {Promise<boolean>} Success status\n   */static async deleteFile(filePath){let sessionId=arguments.length>1&&arguments[1]!==undefined?arguments[1]:null;try{var _checkError$message;// Log deletion attempt for debugging\nconsole.log(\"Attempting to delete file: \".concat(filePath));if(sessionId){console.log(\"Session ID: \".concat(sessionId));}// First attempt: Use the standard remove method\nconst{data,error}=await supabase.storage.from(this.bucketName).remove([filePath]);if(error){var _error$message;console.error('Delete error:',error);console.error('Error details:',{message:error.message,status:error.status,statusCode:error.statusCode});// If standard deletion fails, try using RPC function if available\nif((_error$message=error.message)!==null&&_error$message!==void 0&&_error$message.includes('policy')||error.status===403){console.log('Attempting deletion via RPC function...');try{const{data:rpcData,error:rpcError}=await supabase.rpc('delete_uploaded_file',{p_file_path:filePath,p_session_id:sessionId});if(rpcError){console.error('RPC deletion also failed:',rpcError);return false;}console.log('File deleted via RPC function');return rpcData===true;}catch(rpcErr){console.error('RPC function not available:',rpcErr);// Continue to return false below\n}}return false;}// Check if deletion was successful\n// Supabase returns an array (could be empty or with deleted file info) on success\nif(Array.isArray(data)){// Deletion was successful\nconsole.log('File deleted successfully:',filePath);return true;}// If we didn't get an array, something unexpected happened\nconsole.warn('Delete operation returned unexpected data:',data);// Double-check by trying to get the file\nconst{data:checkData,error:checkError}=await supabase.storage.from(this.bucketName).download(filePath);if(checkError&&(_checkError$message=checkError.message)!==null&&_checkError$message!==void 0&&_checkError$message.includes('not found')){console.log('File verified as deleted (not found)');return true;}else if(!checkError){console.error('File still exists after deletion attempt!');return false;}return false;}catch(error){console.error('Unexpected delete error:',error);return false;}}/**\n   * Delete multiple files (useful for folder deletion)\n   * @param {Array<string>} filePaths - Array of file paths to delete\n   * @param {string} sessionId - Session ID for security verification (optional)\n   * @returns {Promise<Object>} {successful: number, failed: Array}\n   */static async deleteMultipleFiles(filePaths){let sessionId=arguments.length>1&&arguments[1]!==undefined?arguments[1]:null;try{console.log(\"Attempting to delete \".concat(filePaths.length,\" files\"));const{data,error}=await supabase.storage.from(this.bucketName).remove(filePaths);if(error){var _error$message2;console.error('Multiple delete error:',error);// If batch deletion fails, try individual deletions\nif((_error$message2=error.message)!==null&&_error$message2!==void 0&&_error$message2.includes('policy')||error.status===403){console.log('Batch deletion failed, trying individual deletions...');const results=await Promise.allSettled(filePaths.map(path=>this.deleteFile(path,sessionId)));const successful=results.filter(r=>r.status==='fulfilled'&&r.value===true).length;const failed=filePaths.filter((path,index)=>results[index].status==='rejected'||results[index].value===false);return{successful,failed};}return{successful:0,failed:filePaths};}// If we got here, the deletion was successful (no error)\n// Supabase's remove() method doesn't provide detailed success info,\n// but if there's no error, we can assume all files were deleted\nconsole.log(\"Successfully deleted \".concat(filePaths.length,\" files from storage\"));return{successful:filePaths.length,failed:[]};}catch(error){console.error('Unexpected multiple delete error:',error);return{successful:0,failed:filePaths};}}/**\n   * Download a file\n   * @param {string} filePath - Path to file in storage\n   * @returns {Promise<Blob>} File blob\n   */static async downloadFile(filePath){try{const{data,error}=await supabase.storage.from(this.bucketName).download(filePath);if(error){throw error;}return data;}catch(error){console.error('Download error:',error);throw error;}}/**\n   * List files in a folder\n   * @param {string} folderPath - Path to folder\n   * @returns {Promise<Array>} Array of file objects\n   */static async listFiles(){let folderPath=arguments.length>0&&arguments[0]!==undefined?arguments[0]:'';try{const{data,error}=await supabase.storage.from(this.bucketName).list(folderPath);if(error){throw error;}return data||[];}catch(error){console.error('List files error:',error);throw error;}}}// Storage configuration\nSupabaseStorageService.bucketName='service-selection-fileupload';SupabaseStorageService.supabaseUrl=process.env.REACT_APP_SUPABASE_URL||'https://db.ab-civil.com';SupabaseStorageService.maxFileSize=2*1024*1024*1024;// 2GB file size limit\nSupabaseStorageService.allowedTypes=[// Documents\n'application/pdf','application/x-pdf',// Images\n'image/jpeg','image/jpg','image/png','image/gif','image/webp','image/bmp','image/tiff','image/svg+xml',// Spreadsheets\n'application/vnd.ms-excel','application/excel','application/x-excel','application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',// CAD formats\n'application/acad','application/x-acad','application/autocad_dwg','image/x-dwg','application/dwg','image/vnd.dwg','application/x-dwg','application/dxf','application/x-dxf','image/vnd.dxf','image/x-dxf',// Text/Data\n'text/plain','text/csv','application/csv','text/x-csv',// Archive formats\n'application/zip','application/x-zip-compressed','application/x-zip','application/x-rar-compressed','application/vnd.rar','application/rar','application/x-rar',// BIM/CAD formats\n'application/x-step','model/ifc','application/ifc','application/x-ifc','application/octet-stream',// For .rvt and other binary CAD files\n'application/step','model/step','model/x-step','application/p21','application/stp','application/sla','application/vnd.ms-pki.stl','model/stl','application/x-stl',// Additional common types that might be needed\n'',// Some browsers don't set MIME type for certain files\nnull// Handle null MIME types\n];SupabaseStorageService.allowedExtensions=[// Documents\n'.pdf',// Images\n'.jpg','.jpeg','.png','.gif','.webp','.bmp','.tiff','.tif','.svg',// Spreadsheets\n'.xls','.xlsx','.xlsm','.xlsb',// CAD/Engineering\n'.dwg','.dxf','.dwf','.dwfx',// Text/Data\n'.txt','.csv',// Archives\n'.zip','.rar','.7z',// BIM/3D formats\n'.ifc','.rvt','.rfa','.rte','.step','.stp','.stl','.iges','.igs',// Additional CAD formats\n'.sat','.3dm','.3ds','.obj','.dae','.skp'];export default SupabaseStorageService;","map":{"version":3,"names":["supabase","sanitizeFilename","generateSecureId","validateFile","securityValidateFile","SupabaseStorageService","file","fileExtension","name","split","pop","toLowerCase","hasValidExtension","allowedExtensions","includes","hasValidMimeType","type","allowedTypes","console","log","concat","securityValidation","maxSize","maxFileSize","isValid","error","errors","length","doubleExtPattern","test","generateFilePath","formType","companyName","projectName","originalFilename","relativePath","arguments","undefined","uploadSessionId","preserveExactStructure","timestamp","Date","toISOString","sanitizedCompany","substring","sanitizedProject","pathParts","sanitizedParts","map","part","sanitizedRelativePath","join","projectFolder","fileId","sanitizedOriginalFilename","filename","uploadFile","onProgress","signal","sessionId","userId","progressInterval","currentProgress","validation","Error","filePath","setInterval","Math","random","min","floor","uploadOptions","cacheControl","upsert","uploadMetadata","session_id","user_id","Object","keys","metadata","data","storage","from","bucketName","upload","clearInterval","message","Promise","resolve","setTimeout","urlData","getPublicUrl","publicUrl","fileMetadata","id","url","size","uploadDate","path","folder","slice","uploadProcessedFiles","processedFiles","uploadPromises","validFiles","filter","fileObj","valid","invalidFiles","i","push","progress","results","allSettled","successful","failed","forEach","result","index","status","value","reason","uploadMultipleFiles","files","fileArray","Array","webkitRelativePath","deleteFile","_checkError$message","remove","_error$message","statusCode","rpcData","rpcError","rpc","p_file_path","p_session_id","rpcErr","isArray","warn","checkData","checkError","download","deleteMultipleFiles","filePaths","_error$message2","r","downloadFile","listFiles","folderPath","list","supabaseUrl","process","env","REACT_APP_SUPABASE_URL"],"sources":["/Users/adambower/Dev/ab-civil-website-preview/src/shared/services/supabaseStorageService.js"],"sourcesContent":["import { supabase } from '../lib/supabase';\nimport { sanitizeFilename, generateSecureId, validateFile as securityValidateFile } from '../utils/security';\n\nclass SupabaseStorageService {\n  // Storage configuration\n  static bucketName = 'service-selection-fileupload';\n  static supabaseUrl = process.env.REACT_APP_SUPABASE_URL || 'https://db.ab-civil.com';\n  static maxFileSize = 2 * 1024 * 1024 * 1024; // 2GB file size limit\n  static allowedTypes = [\n    // Documents\n    'application/pdf', 'application/x-pdf',\n    \n    // Images\n    'image/jpeg', 'image/jpg', 'image/png', 'image/gif', 'image/webp',\n    'image/bmp', 'image/tiff', 'image/svg+xml',\n    \n    // Spreadsheets\n    'application/vnd.ms-excel', 'application/excel', 'application/x-excel',\n    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\n    \n    // CAD formats\n    'application/acad', 'application/x-acad', 'application/autocad_dwg', \n    'image/x-dwg', 'application/dwg', 'image/vnd.dwg', 'application/x-dwg',\n    'application/dxf', 'application/x-dxf', 'image/vnd.dxf', 'image/x-dxf',\n    \n    // Text/Data\n    'text/plain', 'text/csv', 'application/csv', 'text/x-csv',\n    \n    // Archive formats\n    'application/zip', 'application/x-zip-compressed', 'application/x-zip',\n    'application/x-rar-compressed', 'application/vnd.rar', 'application/rar', 'application/x-rar',\n    \n    // BIM/CAD formats\n    'application/x-step', 'model/ifc', 'application/ifc', 'application/x-ifc',\n    'application/octet-stream', // For .rvt and other binary CAD files\n    'application/step', 'model/step', 'model/x-step', 'application/p21', 'application/stp',\n    'application/sla', 'application/vnd.ms-pki.stl', 'model/stl', 'application/x-stl',\n    \n    // Additional common types that might be needed\n    '', // Some browsers don't set MIME type for certain files\n    null // Handle null MIME types\n  ];\n  static allowedExtensions = [\n    // Documents\n    '.pdf',\n    // Images\n    '.jpg', '.jpeg', '.png', '.gif', '.webp', '.bmp', '.tiff', '.tif', '.svg',\n    // Spreadsheets\n    '.xls', '.xlsx', '.xlsm', '.xlsb',\n    // CAD/Engineering\n    '.dwg', '.dxf', '.dwf', '.dwfx',\n    // Text/Data\n    '.txt', '.csv',\n    // Archives\n    '.zip', '.rar', '.7z',\n    // BIM/3D formats\n    '.ifc', '.rvt', '.rfa', '.rte', '.step', '.stp', '.stl', '.iges', '.igs',\n    // Additional CAD formats\n    '.sat', '.3dm', '.3ds', '.obj', '.dae', '.skp'\n  ];\n\n  /**\n   * Validate file before upload with enhanced security\n   * @param {File} file - File to validate\n   * @returns {Object} {isValid: boolean, error?: string}\n   */\n  static validateFile(file) {\n    // Check file extension first (more reliable than MIME type)\n    const fileExtension = '.' + file.name.split('.').pop().toLowerCase();\n    const hasValidExtension = this.allowedExtensions.includes(fileExtension);\n    \n    // Check MIME type (can be unreliable, so we're more lenient)\n    const hasValidMimeType = !file.type || \n                             file.type === '' || \n                             this.allowedTypes.includes(file.type) ||\n                             this.allowedTypes.includes('application/octet-stream'); // Fallback for unknown types\n    \n    // If extension is valid but MIME type isn't recognized, still allow it\n    if (hasValidExtension && !hasValidMimeType) {\n      console.log(`File ${file.name} has valid extension but unrecognized MIME type: ${file.type}`);\n      // Allow the file since extension is correct\n    } else {\n      // Use security utility for comprehensive validation\n      const securityValidation = securityValidateFile(file, {\n        maxSize: this.maxFileSize,\n        allowedTypes: this.allowedTypes,\n        allowedExtensions: this.allowedExtensions\n      });\n      \n      if (!securityValidation.isValid && !hasValidExtension) {\n        return {\n          isValid: false,\n          error: securityValidation.errors[0] || 'File validation failed'\n        };\n      }\n    }\n\n    // Additional checks for file name\n    if (file.name.length > 255) {\n      return {\n        isValid: false,\n        error: 'File name is too long'\n      };\n    }\n\n    // Check for double extensions (potential bypass attempt)\n    const doubleExtPattern = /\\.[a-z]+\\.[a-z]+$/i;\n    if (doubleExtPattern.test(file.name)) {\n      return {\n        isValid: false,\n        error: 'File names with double extensions are not allowed'\n      };\n    }\n\n    return { isValid: true };\n  }\n\n  /**\n   * Generate organized file path with folder structure preservation\n   * @param {string} formType - Type of form (3d-request, 3d-quote, takeoff-request, takeoff-quote)\n   * @param {string} companyName - Company name\n   * @param {string} projectName - Project name\n   * @param {string} originalFilename - Original file name\n   * @param {string} relativePath - Relative path from folder upload (optional)\n   * @param {string} uploadSessionId - Shared session ID for folder uploads (optional)\n   * @param {boolean} preserveExactStructure - Whether to preserve exact folder structure\n   * @returns {string} File path\n   */\n  static generateFilePath(formType, companyName, projectName, originalFilename, relativePath = null, uploadSessionId = null, preserveExactStructure = true) {\n    const timestamp = new Date().toISOString().split('T')[0];\n    const sanitizedCompany = sanitizeFilename(companyName).substring(0, 50); // Limit company name length\n    const sanitizedProject = sanitizeFilename(projectName).substring(0, 50);\n    \n    // If we have a relative path (from folder upload), preserve the folder structure\n    if (relativePath && relativePath !== originalFilename) {\n      // For folder uploads, preserve the exact structure\n      if (preserveExactStructure) {\n        // Keep the original folder structure intact\n        // Just sanitize each part of the path\n        const pathParts = relativePath.split('/');\n        const sanitizedParts = pathParts.map(part => sanitizeFilename(part));\n        const sanitizedRelativePath = sanitizedParts.join('/');\n        \n        // Create a cleaner structure without redundant timestamps for each file\n        // Format: formType/company/project/original_folder_structure\n        const projectFolder = sanitizedProject || 'misc';\n        return `${formType}/${sanitizedCompany}/${projectFolder}/${sanitizedRelativePath}`;\n      } else {\n        // Legacy behavior with session ID\n        if (!uploadSessionId) {\n          uploadSessionId = generateSecureId(12);\n        }\n        const pathParts = relativePath.split('/');\n        const sanitizedParts = pathParts.map(part => sanitizeFilename(part));\n        const sanitizedRelativePath = sanitizedParts.join('/');\n        return `${formType}/${sanitizedCompany}/${timestamp}_${uploadSessionId}/${sanitizedRelativePath}`;\n      }\n    } else {\n      // Single file upload - use secure ID\n      const fileId = uploadSessionId || generateSecureId(12);\n      const sanitizedOriginalFilename = sanitizeFilename(originalFilename);\n      \n      // For single files, put them in a project folder if specified\n      if (sanitizedProject && preserveExactStructure) {\n        const projectFolder = sanitizedProject;\n        return `${formType}/${sanitizedCompany}/${projectFolder}/${sanitizedOriginalFilename}`;\n      } else {\n        // Legacy behavior\n        const filename = `${timestamp}_${fileId}_${sanitizedOriginalFilename}`;\n        return `${formType}/${sanitizedCompany}/${filename}`;\n      }\n    }\n  }\n\n  /**\n   * Upload a single file to Supabase Storage\n   * @param {File} file - File to upload\n   * @param {string} formType - Type of form\n   * @param {string} companyName - Company name\n   * @param {string} projectName - Project name\n   * @param {Function} onProgress - Progress callback (0-100)\n   * @param {string} relativePath - Relative path for folder structure (optional)\n   * @param {string} uploadSessionId - Shared session ID for folder uploads (optional)\n   * @param {AbortSignal} signal - AbortSignal for cancellation support\n   * @param {string} sessionId - Session ID for security tracking\n   * @param {string} userId - User ID for RLS policies (optional)\n   * @returns {Promise<Object>} File metadata or error\n   */\n  static async uploadFile(file, formType, companyName, projectName, onProgress, relativePath = null, uploadSessionId = null, signal = null, sessionId = null, userId = null) {\n    // Declare progress variables outside try block for proper scope\n    let progressInterval = null;\n    let currentProgress = 0;\n    \n    try {\n      // Validate file\n      const validation = this.validateFile(file);\n      if (!validation.isValid) {\n        throw new Error(validation.error);\n      }\n\n      // Generate file path\n      const filePath = this.generateFilePath(formType, companyName, projectName, file.name, relativePath, uploadSessionId);\n\n      // Start progress simulation since Supabase doesn't provide real progress\n      \n      if (onProgress) {\n        onProgress(5);\n        currentProgress = 5;\n        \n        // Simulate gradual progress during upload\n        progressInterval = setInterval(() => {\n          if (currentProgress < 90) {\n            currentProgress += Math.random() * 3; // Increment by 0-3%\n            currentProgress = Math.min(currentProgress, 90); // Cap at 90%\n            onProgress(Math.floor(currentProgress));\n          }\n        }, 500); // Update every 500ms\n      }\n\n      // Upload file to public bucket with optional abort signal and metadata\n      const uploadOptions = {\n        cacheControl: '3600',\n        upsert: false\n      };\n      \n      // Add metadata for RLS policies\n      const uploadMetadata = {};\n      if (sessionId) {\n        uploadMetadata.session_id = sessionId;\n      }\n      if (userId) {\n        uploadMetadata.user_id = userId;\n      }\n      if (Object.keys(uploadMetadata).length > 0) {\n        uploadOptions.metadata = uploadMetadata;\n      }\n      \n      // Add abort signal if provided\n      if (signal) {\n        uploadOptions.signal = signal;\n      }\n      \n      const { data, error } = await supabase.storage\n        .from(this.bucketName)\n        .upload(filePath, file, uploadOptions);\n\n      // Clear the progress interval\n      if (progressInterval) {\n        clearInterval(progressInterval);\n      }\n\n      if (error) {\n        console.error('Supabase upload error:', error);\n        throw new Error(`Upload failed: ${error.message}`);\n      }\n\n      if (onProgress) {\n        onProgress(95);\n        await new Promise(resolve => setTimeout(resolve, 100));\n      }\n\n      // Get public URL\n      const { data: urlData } = supabase.storage\n        .from(this.bucketName)\n        .getPublicUrl(filePath);\n\n      const publicUrl = urlData?.publicUrl;\n\n      if (!publicUrl) {\n        throw new Error('Failed to generate public URL');\n      }\n\n      if (onProgress) {\n        onProgress(100);\n      }\n\n      // Return file metadata with secure ID\n      const fileMetadata = {\n        id: generateSecureId(16),\n        filename: file.name,\n        url: publicUrl,\n        size: file.size,\n        type: file.type,\n        uploadDate: new Date().toISOString(),\n        path: filePath,\n        relativePath: relativePath || file.name,\n        folder: relativePath ? relativePath.split('/').slice(0, -1).join('/') : ''\n      };\n      \n      // Add session ID if provided for security tracking\n      if (sessionId) {\n        fileMetadata.session_id = sessionId;\n      }\n      \n      // Add user ID if provided for RLS policies\n      if (userId) {\n        fileMetadata.user_id = userId;\n      }\n      \n      return fileMetadata;\n\n    } catch (error) {\n      // Clear the progress interval if it exists\n      if (progressInterval) {\n        clearInterval(progressInterval);\n      }\n      console.error('Upload error:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Upload multiple files (including folder structures)\n   * @param {Array} processedFiles - Array of file objects with metadata from FolderUploadComponent\n   * @param {string} formType - Type of form\n   * @param {string} companyName - Company name\n   * @param {string} projectName - Project name\n   * @param {Function} onProgress - Progress callback per file\n   * @param {string} userId - User ID for RLS policies (optional)\n   * @returns {Promise<Object>} {successful: Array, failed: Array}\n   */\n  static async uploadProcessedFiles(processedFiles, formType, companyName, projectName, onProgress, userId = null) {\n    // Generate secure session ID for all files in this upload batch\n    const sessionId = generateSecureId(12);\n    \n    const uploadPromises = [];\n    \n    // Filter out invalid files\n    const validFiles = processedFiles.filter(fileObj => fileObj.isValid.valid);\n    const invalidFiles = processedFiles.filter(fileObj => !fileObj.isValid.valid);\n\n    for (let i = 0; i < validFiles.length; i++) {\n      const fileObj = validFiles[i];\n      \n      uploadPromises.push(\n        this.uploadFile(\n          fileObj.file,\n          formType,\n          companyName,\n          projectName,\n          (progress) => {\n            if (onProgress) {\n              onProgress(i, progress, fileObj.name);\n            }\n          },\n          fileObj.relativePath,\n          sessionId, // Pass the same sessionId to all files\n          null, // signal\n          sessionId, // sessionId for metadata\n          userId // userId for RLS policies\n        )\n      );\n    }\n\n    try {\n      const results = await Promise.allSettled(uploadPromises);\n      const successful = [];\n      const failed = [...invalidFiles.map(fileObj => ({\n        filename: fileObj.name,\n        error: fileObj.isValid.error\n      }))];\n\n      results.forEach((result, index) => {\n        if (result.status === 'fulfilled') {\n          successful.push(result.value);\n        } else {\n          failed.push({\n            filename: validFiles[index].name,\n            error: result.reason.message || 'Upload failed'\n          });\n        }\n      });\n\n      return { successful, failed };\n    } catch (error) {\n      console.error('Multiple upload error:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Upload multiple files (legacy method for backward compatibility)\n   * @param {FileList|Array} files - Files to upload\n   * @param {string} formType - Type of form\n   * @param {string} companyName - Company name\n   * @param {string} projectName - Project name\n   * @param {Function} onProgress - Progress callback per file\n   * @param {string} userId - User ID for RLS policies (optional)\n   * @returns {Promise<Array>} Array of file metadata\n   */\n  static async uploadMultipleFiles(files, formType, companyName, projectName, onProgress, userId = null) {\n    // Generate secure session ID for all files in this upload batch\n    const sessionId = generateSecureId(12);\n    \n    const uploadPromises = [];\n    const fileArray = Array.from(files);\n\n    for (let i = 0; i < fileArray.length; i++) {\n      const file = fileArray[i];\n      const relativePath = file.webkitRelativePath || file.name;\n      \n      uploadPromises.push(\n        this.uploadFile(\n          file,\n          formType,\n          companyName,\n          projectName,\n          (progress) => {\n            if (onProgress) {\n              onProgress(i, progress, file.name);\n            }\n          },\n          relativePath,\n          sessionId, // Pass the same sessionId to all files\n          null, // signal\n          sessionId, // sessionId for metadata\n          userId // userId for RLS policies\n        )\n      );\n    }\n\n    try {\n      const results = await Promise.allSettled(uploadPromises);\n      const successful = [];\n      const failed = [];\n\n      results.forEach((result, index) => {\n        if (result.status === 'fulfilled') {\n          successful.push(result.value);\n        } else {\n          failed.push({\n            filename: fileArray[index].name,\n            error: result.reason.message || 'Upload failed'\n          });\n        }\n      });\n\n      return { successful, failed };\n    } catch (error) {\n      console.error('Multiple upload error:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Delete a file from storage\n   * @param {string} filePath - Path to file in storage\n   * @param {string} sessionId - Session ID for security verification (optional)\n   * @returns {Promise<boolean>} Success status\n   */\n  static async deleteFile(filePath, sessionId = null) {\n    try {\n      // Log deletion attempt for debugging\n      console.log(`Attempting to delete file: ${filePath}`);\n      if (sessionId) {\n        console.log(`Session ID: ${sessionId}`);\n      }\n      \n      // First attempt: Use the standard remove method\n      const { data, error } = await supabase.storage\n        .from(this.bucketName)\n        .remove([filePath]);\n\n      if (error) {\n        console.error('Delete error:', error);\n        console.error('Error details:', {\n          message: error.message,\n          status: error.status,\n          statusCode: error.statusCode\n        });\n        \n        // If standard deletion fails, try using RPC function if available\n        if (error.message?.includes('policy') || error.status === 403) {\n          console.log('Attempting deletion via RPC function...');\n          try {\n            const { data: rpcData, error: rpcError } = await supabase\n              .rpc('delete_uploaded_file', {\n                p_file_path: filePath,\n                p_session_id: sessionId\n              });\n            \n            if (rpcError) {\n              console.error('RPC deletion also failed:', rpcError);\n              return false;\n            }\n            \n            console.log('File deleted via RPC function');\n            return rpcData === true;\n          } catch (rpcErr) {\n            console.error('RPC function not available:', rpcErr);\n            // Continue to return false below\n          }\n        }\n        \n        return false;\n      }\n\n      // Check if deletion was successful\n      // Supabase returns an array (could be empty or with deleted file info) on success\n      if (Array.isArray(data)) {\n        // Deletion was successful\n        console.log('File deleted successfully:', filePath);\n        return true;\n      }\n      \n      // If we didn't get an array, something unexpected happened\n      console.warn('Delete operation returned unexpected data:', data);\n      \n      // Double-check by trying to get the file\n      const { data: checkData, error: checkError } = await supabase.storage\n        .from(this.bucketName)\n        .download(filePath);\n      \n      if (checkError && checkError.message?.includes('not found')) {\n        console.log('File verified as deleted (not found)');\n        return true;\n      } else if (!checkError) {\n        console.error('File still exists after deletion attempt!');\n        return false;\n      }\n      \n      return false;\n    } catch (error) {\n      console.error('Unexpected delete error:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Delete multiple files (useful for folder deletion)\n   * @param {Array<string>} filePaths - Array of file paths to delete\n   * @param {string} sessionId - Session ID for security verification (optional)\n   * @returns {Promise<Object>} {successful: number, failed: Array}\n   */\n  static async deleteMultipleFiles(filePaths, sessionId = null) {\n    try {\n      console.log(`Attempting to delete ${filePaths.length} files`);\n      \n      const { data, error } = await supabase.storage\n        .from(this.bucketName)\n        .remove(filePaths);\n\n      if (error) {\n        console.error('Multiple delete error:', error);\n        \n        // If batch deletion fails, try individual deletions\n        if (error.message?.includes('policy') || error.status === 403) {\n          console.log('Batch deletion failed, trying individual deletions...');\n          const results = await Promise.allSettled(\n            filePaths.map(path => this.deleteFile(path, sessionId))\n          );\n          \n          const successful = results.filter(r => r.status === 'fulfilled' && r.value === true).length;\n          const failed = filePaths.filter((path, index) => \n            results[index].status === 'rejected' || results[index].value === false\n          );\n          \n          return { successful, failed };\n        }\n        \n        return { successful: 0, failed: filePaths };\n      }\n\n      // If we got here, the deletion was successful (no error)\n      // Supabase's remove() method doesn't provide detailed success info,\n      // but if there's no error, we can assume all files were deleted\n      console.log(`Successfully deleted ${filePaths.length} files from storage`);\n      \n      return { \n        successful: filePaths.length, \n        failed: []\n      };\n    } catch (error) {\n      console.error('Unexpected multiple delete error:', error);\n      return { successful: 0, failed: filePaths };\n    }\n  }\n\n  /**\n   * Download a file\n   * @param {string} filePath - Path to file in storage\n   * @returns {Promise<Blob>} File blob\n   */\n  static async downloadFile(filePath) {\n    try {\n      const { data, error } = await supabase.storage\n        .from(this.bucketName)\n        .download(filePath);\n\n      if (error) {\n        throw error;\n      }\n\n      return data;\n    } catch (error) {\n      console.error('Download error:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * List files in a folder\n   * @param {string} folderPath - Path to folder\n   * @returns {Promise<Array>} Array of file objects\n   */\n  static async listFiles(folderPath = '') {\n    try {\n      const { data, error } = await supabase.storage\n        .from(this.bucketName)\n        .list(folderPath);\n\n      if (error) {\n        throw error;\n      }\n\n      return data || [];\n    } catch (error) {\n      console.error('List files error:', error);\n      throw error;\n    }\n  }\n}\n\nexport default SupabaseStorageService;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}