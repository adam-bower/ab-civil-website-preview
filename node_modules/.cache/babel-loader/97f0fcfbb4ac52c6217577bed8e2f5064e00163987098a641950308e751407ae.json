{"ast":null,"code":"import { supabase } from '../lib/supabase';\nimport { sanitizeFilename, generateSecureId, validateFile as securityValidateFile } from '../utils/security';\nclass SupabaseStorageService {\n  /**\n   * Validate file before upload with enhanced security\n   * @param {File} file - File to validate\n   * @returns {Object} {isValid: boolean, error?: string}\n   */\n  static validateFile(file) {\n    // Check file extension first (more reliable than MIME type)\n    const fileExtension = '.' + file.name.split('.').pop().toLowerCase();\n    const hasValidExtension = this.allowedExtensions.includes(fileExtension);\n\n    // Check MIME type (can be unreliable, so we're more lenient)\n    const hasValidMimeType = !file.type || file.type === '' || this.allowedTypes.includes(file.type) || this.allowedTypes.includes('application/octet-stream'); // Fallback for unknown types\n\n    // If extension is valid but MIME type isn't recognized, still allow it\n    if (hasValidExtension && !hasValidMimeType) {\n      console.log(`File ${file.name} has valid extension but unrecognized MIME type: ${file.type}`);\n      // Allow the file since extension is correct\n    } else {\n      // Use security utility for comprehensive validation\n      const securityValidation = securityValidateFile(file, {\n        maxSize: this.maxFileSize,\n        allowedTypes: this.allowedTypes,\n        allowedExtensions: this.allowedExtensions\n      });\n      if (!securityValidation.isValid && !hasValidExtension) {\n        return {\n          isValid: false,\n          error: securityValidation.errors[0] || 'File validation failed'\n        };\n      }\n    }\n\n    // Additional checks for file name\n    if (file.name.length > 255) {\n      return {\n        isValid: false,\n        error: 'File name is too long'\n      };\n    }\n\n    // Check for double extensions (potential bypass attempt)\n    const doubleExtPattern = /\\.[a-z]+\\.[a-z]+$/i;\n    if (doubleExtPattern.test(file.name)) {\n      return {\n        isValid: false,\n        error: 'File names with double extensions are not allowed'\n      };\n    }\n    return {\n      isValid: true\n    };\n  }\n\n  /**\n   * Generate organized file path with folder structure preservation\n   * @param {string} formType - Type of form (3d-request, 3d-quote, takeoff-request, takeoff-quote)\n   * @param {string} companyName - Company name\n   * @param {string} projectName - Project name\n   * @param {string} originalFilename - Original file name\n   * @param {string} relativePath - Relative path from folder upload (optional)\n   * @param {string} uploadSessionId - Shared session ID for folder uploads (optional)\n   * @param {boolean} preserveExactStructure - Whether to preserve exact folder structure\n   * @returns {string} File path\n   */\n  static generateFilePath(formType, companyName, projectName, originalFilename, relativePath = null, uploadSessionId = null, preserveExactStructure = true) {\n    const timestamp = new Date().toISOString().split('T')[0];\n    const sanitizedCompany = sanitizeFilename(companyName).substring(0, 50); // Limit company name length\n    const sanitizedProject = sanitizeFilename(projectName).substring(0, 50);\n\n    // If we have a relative path (from folder upload), preserve the folder structure\n    if (relativePath && relativePath !== originalFilename) {\n      // For folder uploads, preserve the exact structure\n      if (preserveExactStructure) {\n        // Keep the original folder structure intact\n        // Just sanitize each part of the path\n        const pathParts = relativePath.split('/');\n        const sanitizedParts = pathParts.map(part => sanitizeFilename(part));\n        const sanitizedRelativePath = sanitizedParts.join('/');\n\n        // Create a cleaner structure without redundant timestamps for each file\n        // Format: formType/company/project/original_folder_structure\n        const projectFolder = sanitizedProject || 'misc';\n        return `${formType}/${sanitizedCompany}/${projectFolder}/${sanitizedRelativePath}`;\n      } else {\n        // Legacy behavior with session ID\n        if (!uploadSessionId) {\n          uploadSessionId = generateSecureId(12);\n        }\n        const pathParts = relativePath.split('/');\n        const sanitizedParts = pathParts.map(part => sanitizeFilename(part));\n        const sanitizedRelativePath = sanitizedParts.join('/');\n        return `${formType}/${sanitizedCompany}/${timestamp}_${uploadSessionId}/${sanitizedRelativePath}`;\n      }\n    } else {\n      // Single file upload - use secure ID\n      const fileId = uploadSessionId || generateSecureId(12);\n      const sanitizedOriginalFilename = sanitizeFilename(originalFilename);\n\n      // For single files, put them in a project folder if specified\n      if (sanitizedProject && preserveExactStructure) {\n        const projectFolder = sanitizedProject;\n        return `${formType}/${sanitizedCompany}/${projectFolder}/${sanitizedOriginalFilename}`;\n      } else {\n        // Legacy behavior\n        const filename = `${timestamp}_${fileId}_${sanitizedOriginalFilename}`;\n        return `${formType}/${sanitizedCompany}/${filename}`;\n      }\n    }\n  }\n\n  /**\n   * Upload a single file to Supabase Storage\n   * @param {File} file - File to upload\n   * @param {string} formType - Type of form\n   * @param {string} companyName - Company name\n   * @param {string} projectName - Project name\n   * @param {Function} onProgress - Progress callback (0-100)\n   * @param {string} relativePath - Relative path for folder structure (optional)\n   * @param {string} uploadSessionId - Shared session ID for folder uploads (optional)\n   * @param {AbortSignal} signal - AbortSignal for cancellation support\n   * @param {string} sessionId - Session ID for security tracking\n   * @param {string} userId - User ID for RLS policies (optional)\n   * @returns {Promise<Object>} File metadata or error\n   */\n  static async uploadFile(file, formType, companyName, projectName, onProgress, relativePath = null, uploadSessionId = null, signal = null, sessionId = null, userId = null) {\n    // Declare progress variables outside try block for proper scope\n    let progressInterval = null;\n    let currentProgress = 0;\n    try {\n      // Validate file\n      const validation = this.validateFile(file);\n      if (!validation.isValid) {\n        throw new Error(validation.error);\n      }\n\n      // Generate file path\n      const filePath = this.generateFilePath(formType, companyName, projectName, file.name, relativePath, uploadSessionId);\n\n      // Start progress simulation since Supabase doesn't provide real progress\n\n      if (onProgress) {\n        onProgress(5);\n        currentProgress = 5;\n\n        // Simulate gradual progress during upload\n        progressInterval = setInterval(() => {\n          if (currentProgress < 90) {\n            currentProgress += Math.random() * 3; // Increment by 0-3%\n            currentProgress = Math.min(currentProgress, 90); // Cap at 90%\n            onProgress(Math.floor(currentProgress));\n          }\n        }, 500); // Update every 500ms\n      }\n\n      // Upload file to public bucket with optional abort signal and metadata\n      const uploadOptions = {\n        cacheControl: '3600',\n        upsert: false\n      };\n\n      // Add metadata for RLS policies\n      const uploadMetadata = {};\n      if (sessionId) {\n        uploadMetadata.session_id = sessionId;\n      }\n      if (userId) {\n        uploadMetadata.user_id = userId;\n      }\n      if (Object.keys(uploadMetadata).length > 0) {\n        uploadOptions.metadata = uploadMetadata;\n      }\n\n      // Add abort signal if provided\n      if (signal) {\n        uploadOptions.signal = signal;\n      }\n      const {\n        data,\n        error\n      } = await supabase.storage.from(this.bucketName).upload(filePath, file, uploadOptions);\n\n      // Clear the progress interval\n      if (progressInterval) {\n        clearInterval(progressInterval);\n      }\n      if (error) {\n        console.error('Supabase upload error:', error);\n        throw new Error(`Upload failed: ${error.message}`);\n      }\n      if (onProgress) {\n        onProgress(95);\n        await new Promise(resolve => setTimeout(resolve, 100));\n      }\n\n      // Get public URL\n      const {\n        data: urlData\n      } = supabase.storage.from(this.bucketName).getPublicUrl(filePath);\n      const publicUrl = urlData === null || urlData === void 0 ? void 0 : urlData.publicUrl;\n      if (!publicUrl) {\n        throw new Error('Failed to generate public URL');\n      }\n      if (onProgress) {\n        onProgress(100);\n      }\n\n      // Return file metadata with secure ID\n      const fileMetadata = {\n        id: generateSecureId(16),\n        filename: file.name,\n        url: publicUrl,\n        size: file.size,\n        type: file.type,\n        uploadDate: new Date().toISOString(),\n        path: filePath,\n        relativePath: relativePath || file.name,\n        folder: relativePath ? relativePath.split('/').slice(0, -1).join('/') : ''\n      };\n\n      // Add session ID if provided for security tracking\n      if (sessionId) {\n        fileMetadata.session_id = sessionId;\n      }\n\n      // Add user ID if provided for RLS policies\n      if (userId) {\n        fileMetadata.user_id = userId;\n      }\n      return fileMetadata;\n    } catch (error) {\n      // Clear the progress interval if it exists\n      if (progressInterval) {\n        clearInterval(progressInterval);\n      }\n      console.error('Upload error:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Upload multiple files (including folder structures)\n   * @param {Array} processedFiles - Array of file objects with metadata from FolderUploadComponent\n   * @param {string} formType - Type of form\n   * @param {string} companyName - Company name\n   * @param {string} projectName - Project name\n   * @param {Function} onProgress - Progress callback per file\n   * @param {string} userId - User ID for RLS policies (optional)\n   * @returns {Promise<Object>} {successful: Array, failed: Array}\n   */\n  static async uploadProcessedFiles(processedFiles, formType, companyName, projectName, onProgress, userId = null) {\n    // Generate secure session ID for all files in this upload batch\n    const sessionId = generateSecureId(12);\n    const uploadPromises = [];\n\n    // Filter out invalid files\n    const validFiles = processedFiles.filter(fileObj => fileObj.isValid.valid);\n    const invalidFiles = processedFiles.filter(fileObj => !fileObj.isValid.valid);\n    for (let i = 0; i < validFiles.length; i++) {\n      const fileObj = validFiles[i];\n      uploadPromises.push(this.uploadFile(fileObj.file, formType, companyName, projectName, progress => {\n        if (onProgress) {\n          onProgress(i, progress, fileObj.name);\n        }\n      }, fileObj.relativePath, sessionId,\n      // Pass the same sessionId to all files\n      null,\n      // signal\n      sessionId,\n      // sessionId for metadata\n      userId // userId for RLS policies\n      ));\n    }\n    try {\n      const results = await Promise.allSettled(uploadPromises);\n      const successful = [];\n      const failed = [...invalidFiles.map(fileObj => ({\n        filename: fileObj.name,\n        error: fileObj.isValid.error\n      }))];\n      results.forEach((result, index) => {\n        if (result.status === 'fulfilled') {\n          successful.push(result.value);\n        } else {\n          failed.push({\n            filename: validFiles[index].name,\n            error: result.reason.message || 'Upload failed'\n          });\n        }\n      });\n      return {\n        successful,\n        failed\n      };\n    } catch (error) {\n      console.error('Multiple upload error:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Upload multiple files (legacy method for backward compatibility)\n   * @param {FileList|Array} files - Files to upload\n   * @param {string} formType - Type of form\n   * @param {string} companyName - Company name\n   * @param {string} projectName - Project name\n   * @param {Function} onProgress - Progress callback per file\n   * @param {string} userId - User ID for RLS policies (optional)\n   * @returns {Promise<Array>} Array of file metadata\n   */\n  static async uploadMultipleFiles(files, formType, companyName, projectName, onProgress, userId = null) {\n    // Generate secure session ID for all files in this upload batch\n    const sessionId = generateSecureId(12);\n    const uploadPromises = [];\n    const fileArray = Array.from(files);\n    for (let i = 0; i < fileArray.length; i++) {\n      const file = fileArray[i];\n      const relativePath = file.webkitRelativePath || file.name;\n      uploadPromises.push(this.uploadFile(file, formType, companyName, projectName, progress => {\n        if (onProgress) {\n          onProgress(i, progress, file.name);\n        }\n      }, relativePath, sessionId,\n      // Pass the same sessionId to all files\n      null,\n      // signal\n      sessionId,\n      // sessionId for metadata\n      userId // userId for RLS policies\n      ));\n    }\n    try {\n      const results = await Promise.allSettled(uploadPromises);\n      const successful = [];\n      const failed = [];\n      results.forEach((result, index) => {\n        if (result.status === 'fulfilled') {\n          successful.push(result.value);\n        } else {\n          failed.push({\n            filename: fileArray[index].name,\n            error: result.reason.message || 'Upload failed'\n          });\n        }\n      });\n      return {\n        successful,\n        failed\n      };\n    } catch (error) {\n      console.error('Multiple upload error:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Delete a file from storage\n   * @param {string} filePath - Path to file in storage\n   * @param {string} sessionId - Session ID for security verification (optional)\n   * @returns {Promise<boolean>} Success status\n   */\n  static async deleteFile(filePath, sessionId = null) {\n    try {\n      var _checkError$message;\n      // Log deletion attempt for debugging\n      console.log(`Attempting to delete file: ${filePath}`);\n      if (sessionId) {\n        console.log(`Session ID: ${sessionId}`);\n      }\n\n      // First attempt: Use the standard remove method\n      const {\n        data,\n        error\n      } = await supabase.storage.from(this.bucketName).remove([filePath]);\n      if (error) {\n        var _error$message;\n        console.error('Delete error:', error);\n        console.error('Error details:', {\n          message: error.message,\n          status: error.status,\n          statusCode: error.statusCode\n        });\n\n        // If standard deletion fails, try using RPC function if available\n        if ((_error$message = error.message) !== null && _error$message !== void 0 && _error$message.includes('policy') || error.status === 403) {\n          console.log('Attempting deletion via RPC function...');\n          try {\n            const {\n              data: rpcData,\n              error: rpcError\n            } = await supabase.rpc('delete_uploaded_file', {\n              p_file_path: filePath,\n              p_session_id: sessionId\n            });\n            if (rpcError) {\n              console.error('RPC deletion also failed:', rpcError);\n              return false;\n            }\n            console.log('File deleted via RPC function');\n            return rpcData === true;\n          } catch (rpcErr) {\n            console.error('RPC function not available:', rpcErr);\n            // Continue to return false below\n          }\n        }\n        return false;\n      }\n\n      // Check if deletion was successful\n      // Supabase returns an array (could be empty or with deleted file info) on success\n      if (Array.isArray(data)) {\n        // Deletion was successful\n        console.log('File deleted successfully:', filePath);\n        return true;\n      }\n\n      // If we didn't get an array, something unexpected happened\n      console.warn('Delete operation returned unexpected data:', data);\n\n      // Double-check by trying to get the file\n      const {\n        data: checkData,\n        error: checkError\n      } = await supabase.storage.from(this.bucketName).download(filePath);\n      if (checkError && (_checkError$message = checkError.message) !== null && _checkError$message !== void 0 && _checkError$message.includes('not found')) {\n        console.log('File verified as deleted (not found)');\n        return true;\n      } else if (!checkError) {\n        console.error('File still exists after deletion attempt!');\n        return false;\n      }\n      return false;\n    } catch (error) {\n      console.error('Unexpected delete error:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Delete multiple files (useful for folder deletion)\n   * @param {Array<string>} filePaths - Array of file paths to delete\n   * @param {string} sessionId - Session ID for security verification (optional)\n   * @returns {Promise<Object>} {successful: number, failed: Array}\n   */\n  static async deleteMultipleFiles(filePaths, sessionId = null) {\n    try {\n      console.log(`Attempting to delete ${filePaths.length} files`);\n      const {\n        data,\n        error\n      } = await supabase.storage.from(this.bucketName).remove(filePaths);\n      if (error) {\n        var _error$message2;\n        console.error('Multiple delete error:', error);\n\n        // If batch deletion fails, try individual deletions\n        if ((_error$message2 = error.message) !== null && _error$message2 !== void 0 && _error$message2.includes('policy') || error.status === 403) {\n          console.log('Batch deletion failed, trying individual deletions...');\n          const results = await Promise.allSettled(filePaths.map(path => this.deleteFile(path, sessionId)));\n          const successful = results.filter(r => r.status === 'fulfilled' && r.value === true).length;\n          const failed = filePaths.filter((path, index) => results[index].status === 'rejected' || results[index].value === false);\n          return {\n            successful,\n            failed\n          };\n        }\n        return {\n          successful: 0,\n          failed: filePaths\n        };\n      }\n\n      // If we got here, the deletion was successful (no error)\n      // Supabase's remove() method doesn't provide detailed success info,\n      // but if there's no error, we can assume all files were deleted\n      console.log(`Successfully deleted ${filePaths.length} files from storage`);\n      return {\n        successful: filePaths.length,\n        failed: []\n      };\n    } catch (error) {\n      console.error('Unexpected multiple delete error:', error);\n      return {\n        successful: 0,\n        failed: filePaths\n      };\n    }\n  }\n\n  /**\n   * Download a file\n   * @param {string} filePath - Path to file in storage\n   * @returns {Promise<Blob>} File blob\n   */\n  static async downloadFile(filePath) {\n    try {\n      const {\n        data,\n        error\n      } = await supabase.storage.from(this.bucketName).download(filePath);\n      if (error) {\n        throw error;\n      }\n      return data;\n    } catch (error) {\n      console.error('Download error:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * List files in a folder\n   * @param {string} folderPath - Path to folder\n   * @returns {Promise<Array>} Array of file objects\n   */\n  static async listFiles(folderPath = '') {\n    try {\n      const {\n        data,\n        error\n      } = await supabase.storage.from(this.bucketName).list(folderPath);\n      if (error) {\n        throw error;\n      }\n      return data || [];\n    } catch (error) {\n      console.error('List files error:', error);\n      throw error;\n    }\n  }\n}\n// Storage configuration\nSupabaseStorageService.bucketName = 'service-selection-fileupload';\nSupabaseStorageService.supabaseUrl = process.env.REACT_APP_SUPABASE_URL || 'https://db.ab-civil.com';\nSupabaseStorageService.maxFileSize = 2 * 1024 * 1024 * 1024;\n// 2GB file size limit\nSupabaseStorageService.allowedTypes = [\n// Documents\n'application/pdf', 'application/x-pdf',\n// Images\n'image/jpeg', 'image/jpg', 'image/png', 'image/gif', 'image/webp', 'image/bmp', 'image/tiff', 'image/svg+xml',\n// Spreadsheets\n'application/vnd.ms-excel', 'application/excel', 'application/x-excel', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\n// CAD formats\n'application/acad', 'application/x-acad', 'application/autocad_dwg', 'image/x-dwg', 'application/dwg', 'image/vnd.dwg', 'application/x-dwg', 'application/dxf', 'application/x-dxf', 'image/vnd.dxf', 'image/x-dxf',\n// Text/Data\n'text/plain', 'text/csv', 'application/csv', 'text/x-csv',\n// Archive formats\n'application/zip', 'application/x-zip-compressed', 'application/x-zip', 'application/x-rar-compressed', 'application/vnd.rar', 'application/rar', 'application/x-rar',\n// BIM/CAD formats\n'application/x-step', 'model/ifc', 'application/ifc', 'application/x-ifc', 'application/octet-stream',\n// For .rvt and other binary CAD files\n'application/step', 'model/step', 'model/x-step', 'application/p21', 'application/stp', 'application/sla', 'application/vnd.ms-pki.stl', 'model/stl', 'application/x-stl',\n// Additional common types that might be needed\n'',\n// Some browsers don't set MIME type for certain files\nnull // Handle null MIME types\n];\nSupabaseStorageService.allowedExtensions = [\n// Documents\n'.pdf',\n// Images\n'.jpg', '.jpeg', '.png', '.gif', '.webp', '.bmp', '.tiff', '.tif', '.svg',\n// Spreadsheets\n'.xls', '.xlsx', '.xlsm', '.xlsb',\n// CAD/Engineering\n'.dwg', '.dxf', '.dwf', '.dwfx',\n// Text/Data\n'.txt', '.csv',\n// Archives\n'.zip', '.rar', '.7z',\n// BIM/3D formats\n'.ifc', '.rvt', '.rfa', '.rte', '.step', '.stp', '.stl', '.iges', '.igs',\n// Additional CAD formats\n'.sat', '.3dm', '.3ds', '.obj', '.dae', '.skp'];\nexport default SupabaseStorageService;","map":{"version":3,"names":["supabase","sanitizeFilename","generateSecureId","validateFile","securityValidateFile","SupabaseStorageService","file","fileExtension","name","split","pop","toLowerCase","hasValidExtension","allowedExtensions","includes","hasValidMimeType","type","allowedTypes","console","log","securityValidation","maxSize","maxFileSize","isValid","error","errors","length","doubleExtPattern","test","generateFilePath","formType","companyName","projectName","originalFilename","relativePath","uploadSessionId","preserveExactStructure","timestamp","Date","toISOString","sanitizedCompany","substring","sanitizedProject","pathParts","sanitizedParts","map","part","sanitizedRelativePath","join","projectFolder","fileId","sanitizedOriginalFilename","filename","uploadFile","onProgress","signal","sessionId","userId","progressInterval","currentProgress","validation","Error","filePath","setInterval","Math","random","min","floor","uploadOptions","cacheControl","upsert","uploadMetadata","session_id","user_id","Object","keys","metadata","data","storage","from","bucketName","upload","clearInterval","message","Promise","resolve","setTimeout","urlData","getPublicUrl","publicUrl","fileMetadata","id","url","size","uploadDate","path","folder","slice","uploadProcessedFiles","processedFiles","uploadPromises","validFiles","filter","fileObj","valid","invalidFiles","i","push","progress","results","allSettled","successful","failed","forEach","result","index","status","value","reason","uploadMultipleFiles","files","fileArray","Array","webkitRelativePath","deleteFile","_checkError$message","remove","_error$message","statusCode","rpcData","rpcError","rpc","p_file_path","p_session_id","rpcErr","isArray","warn","checkData","checkError","download","deleteMultipleFiles","filePaths","_error$message2","r","downloadFile","listFiles","folderPath","list","supabaseUrl","process","env","REACT_APP_SUPABASE_URL"],"sources":["/Users/adambower/Dev/ab-civil-website-preview/src/shared/services/supabaseStorageService.js"],"sourcesContent":["import { supabase } from '../lib/supabase';\nimport { sanitizeFilename, generateSecureId, validateFile as securityValidateFile } from '../utils/security';\n\nclass SupabaseStorageService {\n  // Storage configuration\n  static bucketName = 'service-selection-fileupload';\n  static supabaseUrl = process.env.REACT_APP_SUPABASE_URL || 'https://db.ab-civil.com';\n  static maxFileSize = 2 * 1024 * 1024 * 1024; // 2GB file size limit\n  static allowedTypes = [\n    // Documents\n    'application/pdf', 'application/x-pdf',\n    \n    // Images\n    'image/jpeg', 'image/jpg', 'image/png', 'image/gif', 'image/webp',\n    'image/bmp', 'image/tiff', 'image/svg+xml',\n    \n    // Spreadsheets\n    'application/vnd.ms-excel', 'application/excel', 'application/x-excel',\n    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\n    \n    // CAD formats\n    'application/acad', 'application/x-acad', 'application/autocad_dwg', \n    'image/x-dwg', 'application/dwg', 'image/vnd.dwg', 'application/x-dwg',\n    'application/dxf', 'application/x-dxf', 'image/vnd.dxf', 'image/x-dxf',\n    \n    // Text/Data\n    'text/plain', 'text/csv', 'application/csv', 'text/x-csv',\n    \n    // Archive formats\n    'application/zip', 'application/x-zip-compressed', 'application/x-zip',\n    'application/x-rar-compressed', 'application/vnd.rar', 'application/rar', 'application/x-rar',\n    \n    // BIM/CAD formats\n    'application/x-step', 'model/ifc', 'application/ifc', 'application/x-ifc',\n    'application/octet-stream', // For .rvt and other binary CAD files\n    'application/step', 'model/step', 'model/x-step', 'application/p21', 'application/stp',\n    'application/sla', 'application/vnd.ms-pki.stl', 'model/stl', 'application/x-stl',\n    \n    // Additional common types that might be needed\n    '', // Some browsers don't set MIME type for certain files\n    null // Handle null MIME types\n  ];\n  static allowedExtensions = [\n    // Documents\n    '.pdf',\n    // Images\n    '.jpg', '.jpeg', '.png', '.gif', '.webp', '.bmp', '.tiff', '.tif', '.svg',\n    // Spreadsheets\n    '.xls', '.xlsx', '.xlsm', '.xlsb',\n    // CAD/Engineering\n    '.dwg', '.dxf', '.dwf', '.dwfx',\n    // Text/Data\n    '.txt', '.csv',\n    // Archives\n    '.zip', '.rar', '.7z',\n    // BIM/3D formats\n    '.ifc', '.rvt', '.rfa', '.rte', '.step', '.stp', '.stl', '.iges', '.igs',\n    // Additional CAD formats\n    '.sat', '.3dm', '.3ds', '.obj', '.dae', '.skp'\n  ];\n\n  /**\n   * Validate file before upload with enhanced security\n   * @param {File} file - File to validate\n   * @returns {Object} {isValid: boolean, error?: string}\n   */\n  static validateFile(file) {\n    // Check file extension first (more reliable than MIME type)\n    const fileExtension = '.' + file.name.split('.').pop().toLowerCase();\n    const hasValidExtension = this.allowedExtensions.includes(fileExtension);\n    \n    // Check MIME type (can be unreliable, so we're more lenient)\n    const hasValidMimeType = !file.type || \n                             file.type === '' || \n                             this.allowedTypes.includes(file.type) ||\n                             this.allowedTypes.includes('application/octet-stream'); // Fallback for unknown types\n    \n    // If extension is valid but MIME type isn't recognized, still allow it\n    if (hasValidExtension && !hasValidMimeType) {\n      console.log(`File ${file.name} has valid extension but unrecognized MIME type: ${file.type}`);\n      // Allow the file since extension is correct\n    } else {\n      // Use security utility for comprehensive validation\n      const securityValidation = securityValidateFile(file, {\n        maxSize: this.maxFileSize,\n        allowedTypes: this.allowedTypes,\n        allowedExtensions: this.allowedExtensions\n      });\n      \n      if (!securityValidation.isValid && !hasValidExtension) {\n        return {\n          isValid: false,\n          error: securityValidation.errors[0] || 'File validation failed'\n        };\n      }\n    }\n\n    // Additional checks for file name\n    if (file.name.length > 255) {\n      return {\n        isValid: false,\n        error: 'File name is too long'\n      };\n    }\n\n    // Check for double extensions (potential bypass attempt)\n    const doubleExtPattern = /\\.[a-z]+\\.[a-z]+$/i;\n    if (doubleExtPattern.test(file.name)) {\n      return {\n        isValid: false,\n        error: 'File names with double extensions are not allowed'\n      };\n    }\n\n    return { isValid: true };\n  }\n\n  /**\n   * Generate organized file path with folder structure preservation\n   * @param {string} formType - Type of form (3d-request, 3d-quote, takeoff-request, takeoff-quote)\n   * @param {string} companyName - Company name\n   * @param {string} projectName - Project name\n   * @param {string} originalFilename - Original file name\n   * @param {string} relativePath - Relative path from folder upload (optional)\n   * @param {string} uploadSessionId - Shared session ID for folder uploads (optional)\n   * @param {boolean} preserveExactStructure - Whether to preserve exact folder structure\n   * @returns {string} File path\n   */\n  static generateFilePath(formType, companyName, projectName, originalFilename, relativePath = null, uploadSessionId = null, preserveExactStructure = true) {\n    const timestamp = new Date().toISOString().split('T')[0];\n    const sanitizedCompany = sanitizeFilename(companyName).substring(0, 50); // Limit company name length\n    const sanitizedProject = sanitizeFilename(projectName).substring(0, 50);\n    \n    // If we have a relative path (from folder upload), preserve the folder structure\n    if (relativePath && relativePath !== originalFilename) {\n      // For folder uploads, preserve the exact structure\n      if (preserveExactStructure) {\n        // Keep the original folder structure intact\n        // Just sanitize each part of the path\n        const pathParts = relativePath.split('/');\n        const sanitizedParts = pathParts.map(part => sanitizeFilename(part));\n        const sanitizedRelativePath = sanitizedParts.join('/');\n        \n        // Create a cleaner structure without redundant timestamps for each file\n        // Format: formType/company/project/original_folder_structure\n        const projectFolder = sanitizedProject || 'misc';\n        return `${formType}/${sanitizedCompany}/${projectFolder}/${sanitizedRelativePath}`;\n      } else {\n        // Legacy behavior with session ID\n        if (!uploadSessionId) {\n          uploadSessionId = generateSecureId(12);\n        }\n        const pathParts = relativePath.split('/');\n        const sanitizedParts = pathParts.map(part => sanitizeFilename(part));\n        const sanitizedRelativePath = sanitizedParts.join('/');\n        return `${formType}/${sanitizedCompany}/${timestamp}_${uploadSessionId}/${sanitizedRelativePath}`;\n      }\n    } else {\n      // Single file upload - use secure ID\n      const fileId = uploadSessionId || generateSecureId(12);\n      const sanitizedOriginalFilename = sanitizeFilename(originalFilename);\n      \n      // For single files, put them in a project folder if specified\n      if (sanitizedProject && preserveExactStructure) {\n        const projectFolder = sanitizedProject;\n        return `${formType}/${sanitizedCompany}/${projectFolder}/${sanitizedOriginalFilename}`;\n      } else {\n        // Legacy behavior\n        const filename = `${timestamp}_${fileId}_${sanitizedOriginalFilename}`;\n        return `${formType}/${sanitizedCompany}/${filename}`;\n      }\n    }\n  }\n\n  /**\n   * Upload a single file to Supabase Storage\n   * @param {File} file - File to upload\n   * @param {string} formType - Type of form\n   * @param {string} companyName - Company name\n   * @param {string} projectName - Project name\n   * @param {Function} onProgress - Progress callback (0-100)\n   * @param {string} relativePath - Relative path for folder structure (optional)\n   * @param {string} uploadSessionId - Shared session ID for folder uploads (optional)\n   * @param {AbortSignal} signal - AbortSignal for cancellation support\n   * @param {string} sessionId - Session ID for security tracking\n   * @param {string} userId - User ID for RLS policies (optional)\n   * @returns {Promise<Object>} File metadata or error\n   */\n  static async uploadFile(file, formType, companyName, projectName, onProgress, relativePath = null, uploadSessionId = null, signal = null, sessionId = null, userId = null) {\n    // Declare progress variables outside try block for proper scope\n    let progressInterval = null;\n    let currentProgress = 0;\n    \n    try {\n      // Validate file\n      const validation = this.validateFile(file);\n      if (!validation.isValid) {\n        throw new Error(validation.error);\n      }\n\n      // Generate file path\n      const filePath = this.generateFilePath(formType, companyName, projectName, file.name, relativePath, uploadSessionId);\n\n      // Start progress simulation since Supabase doesn't provide real progress\n      \n      if (onProgress) {\n        onProgress(5);\n        currentProgress = 5;\n        \n        // Simulate gradual progress during upload\n        progressInterval = setInterval(() => {\n          if (currentProgress < 90) {\n            currentProgress += Math.random() * 3; // Increment by 0-3%\n            currentProgress = Math.min(currentProgress, 90); // Cap at 90%\n            onProgress(Math.floor(currentProgress));\n          }\n        }, 500); // Update every 500ms\n      }\n\n      // Upload file to public bucket with optional abort signal and metadata\n      const uploadOptions = {\n        cacheControl: '3600',\n        upsert: false\n      };\n      \n      // Add metadata for RLS policies\n      const uploadMetadata = {};\n      if (sessionId) {\n        uploadMetadata.session_id = sessionId;\n      }\n      if (userId) {\n        uploadMetadata.user_id = userId;\n      }\n      if (Object.keys(uploadMetadata).length > 0) {\n        uploadOptions.metadata = uploadMetadata;\n      }\n      \n      // Add abort signal if provided\n      if (signal) {\n        uploadOptions.signal = signal;\n      }\n      \n      const { data, error } = await supabase.storage\n        .from(this.bucketName)\n        .upload(filePath, file, uploadOptions);\n\n      // Clear the progress interval\n      if (progressInterval) {\n        clearInterval(progressInterval);\n      }\n\n      if (error) {\n        console.error('Supabase upload error:', error);\n        throw new Error(`Upload failed: ${error.message}`);\n      }\n\n      if (onProgress) {\n        onProgress(95);\n        await new Promise(resolve => setTimeout(resolve, 100));\n      }\n\n      // Get public URL\n      const { data: urlData } = supabase.storage\n        .from(this.bucketName)\n        .getPublicUrl(filePath);\n\n      const publicUrl = urlData?.publicUrl;\n\n      if (!publicUrl) {\n        throw new Error('Failed to generate public URL');\n      }\n\n      if (onProgress) {\n        onProgress(100);\n      }\n\n      // Return file metadata with secure ID\n      const fileMetadata = {\n        id: generateSecureId(16),\n        filename: file.name,\n        url: publicUrl,\n        size: file.size,\n        type: file.type,\n        uploadDate: new Date().toISOString(),\n        path: filePath,\n        relativePath: relativePath || file.name,\n        folder: relativePath ? relativePath.split('/').slice(0, -1).join('/') : ''\n      };\n      \n      // Add session ID if provided for security tracking\n      if (sessionId) {\n        fileMetadata.session_id = sessionId;\n      }\n      \n      // Add user ID if provided for RLS policies\n      if (userId) {\n        fileMetadata.user_id = userId;\n      }\n      \n      return fileMetadata;\n\n    } catch (error) {\n      // Clear the progress interval if it exists\n      if (progressInterval) {\n        clearInterval(progressInterval);\n      }\n      console.error('Upload error:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Upload multiple files (including folder structures)\n   * @param {Array} processedFiles - Array of file objects with metadata from FolderUploadComponent\n   * @param {string} formType - Type of form\n   * @param {string} companyName - Company name\n   * @param {string} projectName - Project name\n   * @param {Function} onProgress - Progress callback per file\n   * @param {string} userId - User ID for RLS policies (optional)\n   * @returns {Promise<Object>} {successful: Array, failed: Array}\n   */\n  static async uploadProcessedFiles(processedFiles, formType, companyName, projectName, onProgress, userId = null) {\n    // Generate secure session ID for all files in this upload batch\n    const sessionId = generateSecureId(12);\n    \n    const uploadPromises = [];\n    \n    // Filter out invalid files\n    const validFiles = processedFiles.filter(fileObj => fileObj.isValid.valid);\n    const invalidFiles = processedFiles.filter(fileObj => !fileObj.isValid.valid);\n\n    for (let i = 0; i < validFiles.length; i++) {\n      const fileObj = validFiles[i];\n      \n      uploadPromises.push(\n        this.uploadFile(\n          fileObj.file,\n          formType,\n          companyName,\n          projectName,\n          (progress) => {\n            if (onProgress) {\n              onProgress(i, progress, fileObj.name);\n            }\n          },\n          fileObj.relativePath,\n          sessionId, // Pass the same sessionId to all files\n          null, // signal\n          sessionId, // sessionId for metadata\n          userId // userId for RLS policies\n        )\n      );\n    }\n\n    try {\n      const results = await Promise.allSettled(uploadPromises);\n      const successful = [];\n      const failed = [...invalidFiles.map(fileObj => ({\n        filename: fileObj.name,\n        error: fileObj.isValid.error\n      }))];\n\n      results.forEach((result, index) => {\n        if (result.status === 'fulfilled') {\n          successful.push(result.value);\n        } else {\n          failed.push({\n            filename: validFiles[index].name,\n            error: result.reason.message || 'Upload failed'\n          });\n        }\n      });\n\n      return { successful, failed };\n    } catch (error) {\n      console.error('Multiple upload error:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Upload multiple files (legacy method for backward compatibility)\n   * @param {FileList|Array} files - Files to upload\n   * @param {string} formType - Type of form\n   * @param {string} companyName - Company name\n   * @param {string} projectName - Project name\n   * @param {Function} onProgress - Progress callback per file\n   * @param {string} userId - User ID for RLS policies (optional)\n   * @returns {Promise<Array>} Array of file metadata\n   */\n  static async uploadMultipleFiles(files, formType, companyName, projectName, onProgress, userId = null) {\n    // Generate secure session ID for all files in this upload batch\n    const sessionId = generateSecureId(12);\n    \n    const uploadPromises = [];\n    const fileArray = Array.from(files);\n\n    for (let i = 0; i < fileArray.length; i++) {\n      const file = fileArray[i];\n      const relativePath = file.webkitRelativePath || file.name;\n      \n      uploadPromises.push(\n        this.uploadFile(\n          file,\n          formType,\n          companyName,\n          projectName,\n          (progress) => {\n            if (onProgress) {\n              onProgress(i, progress, file.name);\n            }\n          },\n          relativePath,\n          sessionId, // Pass the same sessionId to all files\n          null, // signal\n          sessionId, // sessionId for metadata\n          userId // userId for RLS policies\n        )\n      );\n    }\n\n    try {\n      const results = await Promise.allSettled(uploadPromises);\n      const successful = [];\n      const failed = [];\n\n      results.forEach((result, index) => {\n        if (result.status === 'fulfilled') {\n          successful.push(result.value);\n        } else {\n          failed.push({\n            filename: fileArray[index].name,\n            error: result.reason.message || 'Upload failed'\n          });\n        }\n      });\n\n      return { successful, failed };\n    } catch (error) {\n      console.error('Multiple upload error:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Delete a file from storage\n   * @param {string} filePath - Path to file in storage\n   * @param {string} sessionId - Session ID for security verification (optional)\n   * @returns {Promise<boolean>} Success status\n   */\n  static async deleteFile(filePath, sessionId = null) {\n    try {\n      // Log deletion attempt for debugging\n      console.log(`Attempting to delete file: ${filePath}`);\n      if (sessionId) {\n        console.log(`Session ID: ${sessionId}`);\n      }\n      \n      // First attempt: Use the standard remove method\n      const { data, error } = await supabase.storage\n        .from(this.bucketName)\n        .remove([filePath]);\n\n      if (error) {\n        console.error('Delete error:', error);\n        console.error('Error details:', {\n          message: error.message,\n          status: error.status,\n          statusCode: error.statusCode\n        });\n        \n        // If standard deletion fails, try using RPC function if available\n        if (error.message?.includes('policy') || error.status === 403) {\n          console.log('Attempting deletion via RPC function...');\n          try {\n            const { data: rpcData, error: rpcError } = await supabase\n              .rpc('delete_uploaded_file', {\n                p_file_path: filePath,\n                p_session_id: sessionId\n              });\n            \n            if (rpcError) {\n              console.error('RPC deletion also failed:', rpcError);\n              return false;\n            }\n            \n            console.log('File deleted via RPC function');\n            return rpcData === true;\n          } catch (rpcErr) {\n            console.error('RPC function not available:', rpcErr);\n            // Continue to return false below\n          }\n        }\n        \n        return false;\n      }\n\n      // Check if deletion was successful\n      // Supabase returns an array (could be empty or with deleted file info) on success\n      if (Array.isArray(data)) {\n        // Deletion was successful\n        console.log('File deleted successfully:', filePath);\n        return true;\n      }\n      \n      // If we didn't get an array, something unexpected happened\n      console.warn('Delete operation returned unexpected data:', data);\n      \n      // Double-check by trying to get the file\n      const { data: checkData, error: checkError } = await supabase.storage\n        .from(this.bucketName)\n        .download(filePath);\n      \n      if (checkError && checkError.message?.includes('not found')) {\n        console.log('File verified as deleted (not found)');\n        return true;\n      } else if (!checkError) {\n        console.error('File still exists after deletion attempt!');\n        return false;\n      }\n      \n      return false;\n    } catch (error) {\n      console.error('Unexpected delete error:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Delete multiple files (useful for folder deletion)\n   * @param {Array<string>} filePaths - Array of file paths to delete\n   * @param {string} sessionId - Session ID for security verification (optional)\n   * @returns {Promise<Object>} {successful: number, failed: Array}\n   */\n  static async deleteMultipleFiles(filePaths, sessionId = null) {\n    try {\n      console.log(`Attempting to delete ${filePaths.length} files`);\n      \n      const { data, error } = await supabase.storage\n        .from(this.bucketName)\n        .remove(filePaths);\n\n      if (error) {\n        console.error('Multiple delete error:', error);\n        \n        // If batch deletion fails, try individual deletions\n        if (error.message?.includes('policy') || error.status === 403) {\n          console.log('Batch deletion failed, trying individual deletions...');\n          const results = await Promise.allSettled(\n            filePaths.map(path => this.deleteFile(path, sessionId))\n          );\n          \n          const successful = results.filter(r => r.status === 'fulfilled' && r.value === true).length;\n          const failed = filePaths.filter((path, index) => \n            results[index].status === 'rejected' || results[index].value === false\n          );\n          \n          return { successful, failed };\n        }\n        \n        return { successful: 0, failed: filePaths };\n      }\n\n      // If we got here, the deletion was successful (no error)\n      // Supabase's remove() method doesn't provide detailed success info,\n      // but if there's no error, we can assume all files were deleted\n      console.log(`Successfully deleted ${filePaths.length} files from storage`);\n      \n      return { \n        successful: filePaths.length, \n        failed: []\n      };\n    } catch (error) {\n      console.error('Unexpected multiple delete error:', error);\n      return { successful: 0, failed: filePaths };\n    }\n  }\n\n  /**\n   * Download a file\n   * @param {string} filePath - Path to file in storage\n   * @returns {Promise<Blob>} File blob\n   */\n  static async downloadFile(filePath) {\n    try {\n      const { data, error } = await supabase.storage\n        .from(this.bucketName)\n        .download(filePath);\n\n      if (error) {\n        throw error;\n      }\n\n      return data;\n    } catch (error) {\n      console.error('Download error:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * List files in a folder\n   * @param {string} folderPath - Path to folder\n   * @returns {Promise<Array>} Array of file objects\n   */\n  static async listFiles(folderPath = '') {\n    try {\n      const { data, error } = await supabase.storage\n        .from(this.bucketName)\n        .list(folderPath);\n\n      if (error) {\n        throw error;\n      }\n\n      return data || [];\n    } catch (error) {\n      console.error('List files error:', error);\n      throw error;\n    }\n  }\n}\n\nexport default SupabaseStorageService;"],"mappings":"AAAA,SAASA,QAAQ,QAAQ,iBAAiB;AAC1C,SAASC,gBAAgB,EAAEC,gBAAgB,EAAEC,YAAY,IAAIC,oBAAoB,QAAQ,mBAAmB;AAE5G,MAAMC,sBAAsB,CAAC;EA0D3B;AACF;AACA;AACA;AACA;EACE,OAAOF,YAAYA,CAACG,IAAI,EAAE;IACxB;IACA,MAAMC,aAAa,GAAG,GAAG,GAAGD,IAAI,CAACE,IAAI,CAACC,KAAK,CAAC,GAAG,CAAC,CAACC,GAAG,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC;IACpE,MAAMC,iBAAiB,GAAG,IAAI,CAACC,iBAAiB,CAACC,QAAQ,CAACP,aAAa,CAAC;;IAExE;IACA,MAAMQ,gBAAgB,GAAG,CAACT,IAAI,CAACU,IAAI,IACVV,IAAI,CAACU,IAAI,KAAK,EAAE,IAChB,IAAI,CAACC,YAAY,CAACH,QAAQ,CAACR,IAAI,CAACU,IAAI,CAAC,IACrC,IAAI,CAACC,YAAY,CAACH,QAAQ,CAAC,0BAA0B,CAAC,CAAC,CAAC;;IAEjF;IACA,IAAIF,iBAAiB,IAAI,CAACG,gBAAgB,EAAE;MAC1CG,OAAO,CAACC,GAAG,CAAC,QAAQb,IAAI,CAACE,IAAI,oDAAoDF,IAAI,CAACU,IAAI,EAAE,CAAC;MAC7F;IACF,CAAC,MAAM;MACL;MACA,MAAMI,kBAAkB,GAAGhB,oBAAoB,CAACE,IAAI,EAAE;QACpDe,OAAO,EAAE,IAAI,CAACC,WAAW;QACzBL,YAAY,EAAE,IAAI,CAACA,YAAY;QAC/BJ,iBAAiB,EAAE,IAAI,CAACA;MAC1B,CAAC,CAAC;MAEF,IAAI,CAACO,kBAAkB,CAACG,OAAO,IAAI,CAACX,iBAAiB,EAAE;QACrD,OAAO;UACLW,OAAO,EAAE,KAAK;UACdC,KAAK,EAAEJ,kBAAkB,CAACK,MAAM,CAAC,CAAC,CAAC,IAAI;QACzC,CAAC;MACH;IACF;;IAEA;IACA,IAAInB,IAAI,CAACE,IAAI,CAACkB,MAAM,GAAG,GAAG,EAAE;MAC1B,OAAO;QACLH,OAAO,EAAE,KAAK;QACdC,KAAK,EAAE;MACT,CAAC;IACH;;IAEA;IACA,MAAMG,gBAAgB,GAAG,oBAAoB;IAC7C,IAAIA,gBAAgB,CAACC,IAAI,CAACtB,IAAI,CAACE,IAAI,CAAC,EAAE;MACpC,OAAO;QACLe,OAAO,EAAE,KAAK;QACdC,KAAK,EAAE;MACT,CAAC;IACH;IAEA,OAAO;MAAED,OAAO,EAAE;IAAK,CAAC;EAC1B;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,OAAOM,gBAAgBA,CAACC,QAAQ,EAAEC,WAAW,EAAEC,WAAW,EAAEC,gBAAgB,EAAEC,YAAY,GAAG,IAAI,EAAEC,eAAe,GAAG,IAAI,EAAEC,sBAAsB,GAAG,IAAI,EAAE;IACxJ,MAAMC,SAAS,GAAG,IAAIC,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC,CAAC9B,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;IACxD,MAAM+B,gBAAgB,GAAGvC,gBAAgB,CAAC8B,WAAW,CAAC,CAACU,SAAS,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;IACzE,MAAMC,gBAAgB,GAAGzC,gBAAgB,CAAC+B,WAAW,CAAC,CAACS,SAAS,CAAC,CAAC,EAAE,EAAE,CAAC;;IAEvE;IACA,IAAIP,YAAY,IAAIA,YAAY,KAAKD,gBAAgB,EAAE;MACrD;MACA,IAAIG,sBAAsB,EAAE;QAC1B;QACA;QACA,MAAMO,SAAS,GAAGT,YAAY,CAACzB,KAAK,CAAC,GAAG,CAAC;QACzC,MAAMmC,cAAc,GAAGD,SAAS,CAACE,GAAG,CAACC,IAAI,IAAI7C,gBAAgB,CAAC6C,IAAI,CAAC,CAAC;QACpE,MAAMC,qBAAqB,GAAGH,cAAc,CAACI,IAAI,CAAC,GAAG,CAAC;;QAEtD;QACA;QACA,MAAMC,aAAa,GAAGP,gBAAgB,IAAI,MAAM;QAChD,OAAO,GAAGZ,QAAQ,IAAIU,gBAAgB,IAAIS,aAAa,IAAIF,qBAAqB,EAAE;MACpF,CAAC,MAAM;QACL;QACA,IAAI,CAACZ,eAAe,EAAE;UACpBA,eAAe,GAAGjC,gBAAgB,CAAC,EAAE,CAAC;QACxC;QACA,MAAMyC,SAAS,GAAGT,YAAY,CAACzB,KAAK,CAAC,GAAG,CAAC;QACzC,MAAMmC,cAAc,GAAGD,SAAS,CAACE,GAAG,CAACC,IAAI,IAAI7C,gBAAgB,CAAC6C,IAAI,CAAC,CAAC;QACpE,MAAMC,qBAAqB,GAAGH,cAAc,CAACI,IAAI,CAAC,GAAG,CAAC;QACtD,OAAO,GAAGlB,QAAQ,IAAIU,gBAAgB,IAAIH,SAAS,IAAIF,eAAe,IAAIY,qBAAqB,EAAE;MACnG;IACF,CAAC,MAAM;MACL;MACA,MAAMG,MAAM,GAAGf,eAAe,IAAIjC,gBAAgB,CAAC,EAAE,CAAC;MACtD,MAAMiD,yBAAyB,GAAGlD,gBAAgB,CAACgC,gBAAgB,CAAC;;MAEpE;MACA,IAAIS,gBAAgB,IAAIN,sBAAsB,EAAE;QAC9C,MAAMa,aAAa,GAAGP,gBAAgB;QACtC,OAAO,GAAGZ,QAAQ,IAAIU,gBAAgB,IAAIS,aAAa,IAAIE,yBAAyB,EAAE;MACxF,CAAC,MAAM;QACL;QACA,MAAMC,QAAQ,GAAG,GAAGf,SAAS,IAAIa,MAAM,IAAIC,yBAAyB,EAAE;QACtE,OAAO,GAAGrB,QAAQ,IAAIU,gBAAgB,IAAIY,QAAQ,EAAE;MACtD;IACF;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,aAAaC,UAAUA,CAAC/C,IAAI,EAAEwB,QAAQ,EAAEC,WAAW,EAAEC,WAAW,EAAEsB,UAAU,EAAEpB,YAAY,GAAG,IAAI,EAAEC,eAAe,GAAG,IAAI,EAAEoB,MAAM,GAAG,IAAI,EAAEC,SAAS,GAAG,IAAI,EAAEC,MAAM,GAAG,IAAI,EAAE;IACzK;IACA,IAAIC,gBAAgB,GAAG,IAAI;IAC3B,IAAIC,eAAe,GAAG,CAAC;IAEvB,IAAI;MACF;MACA,MAAMC,UAAU,GAAG,IAAI,CAACzD,YAAY,CAACG,IAAI,CAAC;MAC1C,IAAI,CAACsD,UAAU,CAACrC,OAAO,EAAE;QACvB,MAAM,IAAIsC,KAAK,CAACD,UAAU,CAACpC,KAAK,CAAC;MACnC;;MAEA;MACA,MAAMsC,QAAQ,GAAG,IAAI,CAACjC,gBAAgB,CAACC,QAAQ,EAAEC,WAAW,EAAEC,WAAW,EAAE1B,IAAI,CAACE,IAAI,EAAE0B,YAAY,EAAEC,eAAe,CAAC;;MAEpH;;MAEA,IAAImB,UAAU,EAAE;QACdA,UAAU,CAAC,CAAC,CAAC;QACbK,eAAe,GAAG,CAAC;;QAEnB;QACAD,gBAAgB,GAAGK,WAAW,CAAC,MAAM;UACnC,IAAIJ,eAAe,GAAG,EAAE,EAAE;YACxBA,eAAe,IAAIK,IAAI,CAACC,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;YACtCN,eAAe,GAAGK,IAAI,CAACE,GAAG,CAACP,eAAe,EAAE,EAAE,CAAC,CAAC,CAAC;YACjDL,UAAU,CAACU,IAAI,CAACG,KAAK,CAACR,eAAe,CAAC,CAAC;UACzC;QACF,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC;MACX;;MAEA;MACA,MAAMS,aAAa,GAAG;QACpBC,YAAY,EAAE,MAAM;QACpBC,MAAM,EAAE;MACV,CAAC;;MAED;MACA,MAAMC,cAAc,GAAG,CAAC,CAAC;MACzB,IAAIf,SAAS,EAAE;QACbe,cAAc,CAACC,UAAU,GAAGhB,SAAS;MACvC;MACA,IAAIC,MAAM,EAAE;QACVc,cAAc,CAACE,OAAO,GAAGhB,MAAM;MACjC;MACA,IAAIiB,MAAM,CAACC,IAAI,CAACJ,cAAc,CAAC,CAAC7C,MAAM,GAAG,CAAC,EAAE;QAC1C0C,aAAa,CAACQ,QAAQ,GAAGL,cAAc;MACzC;;MAEA;MACA,IAAIhB,MAAM,EAAE;QACVa,aAAa,CAACb,MAAM,GAAGA,MAAM;MAC/B;MAEA,MAAM;QAAEsB,IAAI;QAAErD;MAAM,CAAC,GAAG,MAAMxB,QAAQ,CAAC8E,OAAO,CAC3CC,IAAI,CAAC,IAAI,CAACC,UAAU,CAAC,CACrBC,MAAM,CAACnB,QAAQ,EAAExD,IAAI,EAAE8D,aAAa,CAAC;;MAExC;MACA,IAAIV,gBAAgB,EAAE;QACpBwB,aAAa,CAACxB,gBAAgB,CAAC;MACjC;MAEA,IAAIlC,KAAK,EAAE;QACTN,OAAO,CAACM,KAAK,CAAC,wBAAwB,EAAEA,KAAK,CAAC;QAC9C,MAAM,IAAIqC,KAAK,CAAC,kBAAkBrC,KAAK,CAAC2D,OAAO,EAAE,CAAC;MACpD;MAEA,IAAI7B,UAAU,EAAE;QACdA,UAAU,CAAC,EAAE,CAAC;QACd,MAAM,IAAI8B,OAAO,CAACC,OAAO,IAAIC,UAAU,CAACD,OAAO,EAAE,GAAG,CAAC,CAAC;MACxD;;MAEA;MACA,MAAM;QAAER,IAAI,EAAEU;MAAQ,CAAC,GAAGvF,QAAQ,CAAC8E,OAAO,CACvCC,IAAI,CAAC,IAAI,CAACC,UAAU,CAAC,CACrBQ,YAAY,CAAC1B,QAAQ,CAAC;MAEzB,MAAM2B,SAAS,GAAGF,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEE,SAAS;MAEpC,IAAI,CAACA,SAAS,EAAE;QACd,MAAM,IAAI5B,KAAK,CAAC,+BAA+B,CAAC;MAClD;MAEA,IAAIP,UAAU,EAAE;QACdA,UAAU,CAAC,GAAG,CAAC;MACjB;;MAEA;MACA,MAAMoC,YAAY,GAAG;QACnBC,EAAE,EAAEzF,gBAAgB,CAAC,EAAE,CAAC;QACxBkD,QAAQ,EAAE9C,IAAI,CAACE,IAAI;QACnBoF,GAAG,EAAEH,SAAS;QACdI,IAAI,EAAEvF,IAAI,CAACuF,IAAI;QACf7E,IAAI,EAAEV,IAAI,CAACU,IAAI;QACf8E,UAAU,EAAE,IAAIxD,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC;QACpCwD,IAAI,EAAEjC,QAAQ;QACd5B,YAAY,EAAEA,YAAY,IAAI5B,IAAI,CAACE,IAAI;QACvCwF,MAAM,EAAE9D,YAAY,GAAGA,YAAY,CAACzB,KAAK,CAAC,GAAG,CAAC,CAACwF,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAACjD,IAAI,CAAC,GAAG,CAAC,GAAG;MAC1E,CAAC;;MAED;MACA,IAAIQ,SAAS,EAAE;QACbkC,YAAY,CAAClB,UAAU,GAAGhB,SAAS;MACrC;;MAEA;MACA,IAAIC,MAAM,EAAE;QACViC,YAAY,CAACjB,OAAO,GAAGhB,MAAM;MAC/B;MAEA,OAAOiC,YAAY;IAErB,CAAC,CAAC,OAAOlE,KAAK,EAAE;MACd;MACA,IAAIkC,gBAAgB,EAAE;QACpBwB,aAAa,CAACxB,gBAAgB,CAAC;MACjC;MACAxC,OAAO,CAACM,KAAK,CAAC,eAAe,EAAEA,KAAK,CAAC;MACrC,MAAMA,KAAK;IACb;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,aAAa0E,oBAAoBA,CAACC,cAAc,EAAErE,QAAQ,EAAEC,WAAW,EAAEC,WAAW,EAAEsB,UAAU,EAAEG,MAAM,GAAG,IAAI,EAAE;IAC/G;IACA,MAAMD,SAAS,GAAGtD,gBAAgB,CAAC,EAAE,CAAC;IAEtC,MAAMkG,cAAc,GAAG,EAAE;;IAEzB;IACA,MAAMC,UAAU,GAAGF,cAAc,CAACG,MAAM,CAACC,OAAO,IAAIA,OAAO,CAAChF,OAAO,CAACiF,KAAK,CAAC;IAC1E,MAAMC,YAAY,GAAGN,cAAc,CAACG,MAAM,CAACC,OAAO,IAAI,CAACA,OAAO,CAAChF,OAAO,CAACiF,KAAK,CAAC;IAE7E,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,UAAU,CAAC3E,MAAM,EAAEgF,CAAC,EAAE,EAAE;MAC1C,MAAMH,OAAO,GAAGF,UAAU,CAACK,CAAC,CAAC;MAE7BN,cAAc,CAACO,IAAI,CACjB,IAAI,CAACtD,UAAU,CACbkD,OAAO,CAACjG,IAAI,EACZwB,QAAQ,EACRC,WAAW,EACXC,WAAW,EACV4E,QAAQ,IAAK;QACZ,IAAItD,UAAU,EAAE;UACdA,UAAU,CAACoD,CAAC,EAAEE,QAAQ,EAAEL,OAAO,CAAC/F,IAAI,CAAC;QACvC;MACF,CAAC,EACD+F,OAAO,CAACrE,YAAY,EACpBsB,SAAS;MAAE;MACX,IAAI;MAAE;MACNA,SAAS;MAAE;MACXC,MAAM,CAAC;MACT,CACF,CAAC;IACH;IAEA,IAAI;MACF,MAAMoD,OAAO,GAAG,MAAMzB,OAAO,CAAC0B,UAAU,CAACV,cAAc,CAAC;MACxD,MAAMW,UAAU,GAAG,EAAE;MACrB,MAAMC,MAAM,GAAG,CAAC,GAAGP,YAAY,CAAC5D,GAAG,CAAC0D,OAAO,KAAK;QAC9CnD,QAAQ,EAAEmD,OAAO,CAAC/F,IAAI;QACtBgB,KAAK,EAAE+E,OAAO,CAAChF,OAAO,CAACC;MACzB,CAAC,CAAC,CAAC,CAAC;MAEJqF,OAAO,CAACI,OAAO,CAAC,CAACC,MAAM,EAAEC,KAAK,KAAK;QACjC,IAAID,MAAM,CAACE,MAAM,KAAK,WAAW,EAAE;UACjCL,UAAU,CAACJ,IAAI,CAACO,MAAM,CAACG,KAAK,CAAC;QAC/B,CAAC,MAAM;UACLL,MAAM,CAACL,IAAI,CAAC;YACVvD,QAAQ,EAAEiD,UAAU,CAACc,KAAK,CAAC,CAAC3G,IAAI;YAChCgB,KAAK,EAAE0F,MAAM,CAACI,MAAM,CAACnC,OAAO,IAAI;UAClC,CAAC,CAAC;QACJ;MACF,CAAC,CAAC;MAEF,OAAO;QAAE4B,UAAU;QAAEC;MAAO,CAAC;IAC/B,CAAC,CAAC,OAAOxF,KAAK,EAAE;MACdN,OAAO,CAACM,KAAK,CAAC,wBAAwB,EAAEA,KAAK,CAAC;MAC9C,MAAMA,KAAK;IACb;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,aAAa+F,mBAAmBA,CAACC,KAAK,EAAE1F,QAAQ,EAAEC,WAAW,EAAEC,WAAW,EAAEsB,UAAU,EAAEG,MAAM,GAAG,IAAI,EAAE;IACrG;IACA,MAAMD,SAAS,GAAGtD,gBAAgB,CAAC,EAAE,CAAC;IAEtC,MAAMkG,cAAc,GAAG,EAAE;IACzB,MAAMqB,SAAS,GAAGC,KAAK,CAAC3C,IAAI,CAACyC,KAAK,CAAC;IAEnC,KAAK,IAAId,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGe,SAAS,CAAC/F,MAAM,EAAEgF,CAAC,EAAE,EAAE;MACzC,MAAMpG,IAAI,GAAGmH,SAAS,CAACf,CAAC,CAAC;MACzB,MAAMxE,YAAY,GAAG5B,IAAI,CAACqH,kBAAkB,IAAIrH,IAAI,CAACE,IAAI;MAEzD4F,cAAc,CAACO,IAAI,CACjB,IAAI,CAACtD,UAAU,CACb/C,IAAI,EACJwB,QAAQ,EACRC,WAAW,EACXC,WAAW,EACV4E,QAAQ,IAAK;QACZ,IAAItD,UAAU,EAAE;UACdA,UAAU,CAACoD,CAAC,EAAEE,QAAQ,EAAEtG,IAAI,CAACE,IAAI,CAAC;QACpC;MACF,CAAC,EACD0B,YAAY,EACZsB,SAAS;MAAE;MACX,IAAI;MAAE;MACNA,SAAS;MAAE;MACXC,MAAM,CAAC;MACT,CACF,CAAC;IACH;IAEA,IAAI;MACF,MAAMoD,OAAO,GAAG,MAAMzB,OAAO,CAAC0B,UAAU,CAACV,cAAc,CAAC;MACxD,MAAMW,UAAU,GAAG,EAAE;MACrB,MAAMC,MAAM,GAAG,EAAE;MAEjBH,OAAO,CAACI,OAAO,CAAC,CAACC,MAAM,EAAEC,KAAK,KAAK;QACjC,IAAID,MAAM,CAACE,MAAM,KAAK,WAAW,EAAE;UACjCL,UAAU,CAACJ,IAAI,CAACO,MAAM,CAACG,KAAK,CAAC;QAC/B,CAAC,MAAM;UACLL,MAAM,CAACL,IAAI,CAAC;YACVvD,QAAQ,EAAEqE,SAAS,CAACN,KAAK,CAAC,CAAC3G,IAAI;YAC/BgB,KAAK,EAAE0F,MAAM,CAACI,MAAM,CAACnC,OAAO,IAAI;UAClC,CAAC,CAAC;QACJ;MACF,CAAC,CAAC;MAEF,OAAO;QAAE4B,UAAU;QAAEC;MAAO,CAAC;IAC/B,CAAC,CAAC,OAAOxF,KAAK,EAAE;MACdN,OAAO,CAACM,KAAK,CAAC,wBAAwB,EAAEA,KAAK,CAAC;MAC9C,MAAMA,KAAK;IACb;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;EACE,aAAaoG,UAAUA,CAAC9D,QAAQ,EAAEN,SAAS,GAAG,IAAI,EAAE;IAClD,IAAI;MAAA,IAAAqE,mBAAA;MACF;MACA3G,OAAO,CAACC,GAAG,CAAC,8BAA8B2C,QAAQ,EAAE,CAAC;MACrD,IAAIN,SAAS,EAAE;QACbtC,OAAO,CAACC,GAAG,CAAC,eAAeqC,SAAS,EAAE,CAAC;MACzC;;MAEA;MACA,MAAM;QAAEqB,IAAI;QAAErD;MAAM,CAAC,GAAG,MAAMxB,QAAQ,CAAC8E,OAAO,CAC3CC,IAAI,CAAC,IAAI,CAACC,UAAU,CAAC,CACrB8C,MAAM,CAAC,CAAChE,QAAQ,CAAC,CAAC;MAErB,IAAItC,KAAK,EAAE;QAAA,IAAAuG,cAAA;QACT7G,OAAO,CAACM,KAAK,CAAC,eAAe,EAAEA,KAAK,CAAC;QACrCN,OAAO,CAACM,KAAK,CAAC,gBAAgB,EAAE;UAC9B2D,OAAO,EAAE3D,KAAK,CAAC2D,OAAO;UACtBiC,MAAM,EAAE5F,KAAK,CAAC4F,MAAM;UACpBY,UAAU,EAAExG,KAAK,CAACwG;QACpB,CAAC,CAAC;;QAEF;QACA,IAAI,CAAAD,cAAA,GAAAvG,KAAK,CAAC2D,OAAO,cAAA4C,cAAA,eAAbA,cAAA,CAAejH,QAAQ,CAAC,QAAQ,CAAC,IAAIU,KAAK,CAAC4F,MAAM,KAAK,GAAG,EAAE;UAC7DlG,OAAO,CAACC,GAAG,CAAC,yCAAyC,CAAC;UACtD,IAAI;YACF,MAAM;cAAE0D,IAAI,EAAEoD,OAAO;cAAEzG,KAAK,EAAE0G;YAAS,CAAC,GAAG,MAAMlI,QAAQ,CACtDmI,GAAG,CAAC,sBAAsB,EAAE;cAC3BC,WAAW,EAAEtE,QAAQ;cACrBuE,YAAY,EAAE7E;YAChB,CAAC,CAAC;YAEJ,IAAI0E,QAAQ,EAAE;cACZhH,OAAO,CAACM,KAAK,CAAC,2BAA2B,EAAE0G,QAAQ,CAAC;cACpD,OAAO,KAAK;YACd;YAEAhH,OAAO,CAACC,GAAG,CAAC,+BAA+B,CAAC;YAC5C,OAAO8G,OAAO,KAAK,IAAI;UACzB,CAAC,CAAC,OAAOK,MAAM,EAAE;YACfpH,OAAO,CAACM,KAAK,CAAC,6BAA6B,EAAE8G,MAAM,CAAC;YACpD;UACF;QACF;QAEA,OAAO,KAAK;MACd;;MAEA;MACA;MACA,IAAIZ,KAAK,CAACa,OAAO,CAAC1D,IAAI,CAAC,EAAE;QACvB;QACA3D,OAAO,CAACC,GAAG,CAAC,4BAA4B,EAAE2C,QAAQ,CAAC;QACnD,OAAO,IAAI;MACb;;MAEA;MACA5C,OAAO,CAACsH,IAAI,CAAC,4CAA4C,EAAE3D,IAAI,CAAC;;MAEhE;MACA,MAAM;QAAEA,IAAI,EAAE4D,SAAS;QAAEjH,KAAK,EAAEkH;MAAW,CAAC,GAAG,MAAM1I,QAAQ,CAAC8E,OAAO,CAClEC,IAAI,CAAC,IAAI,CAACC,UAAU,CAAC,CACrB2D,QAAQ,CAAC7E,QAAQ,CAAC;MAErB,IAAI4E,UAAU,KAAAb,mBAAA,GAAIa,UAAU,CAACvD,OAAO,cAAA0C,mBAAA,eAAlBA,mBAAA,CAAoB/G,QAAQ,CAAC,WAAW,CAAC,EAAE;QAC3DI,OAAO,CAACC,GAAG,CAAC,sCAAsC,CAAC;QACnD,OAAO,IAAI;MACb,CAAC,MAAM,IAAI,CAACuH,UAAU,EAAE;QACtBxH,OAAO,CAACM,KAAK,CAAC,2CAA2C,CAAC;QAC1D,OAAO,KAAK;MACd;MAEA,OAAO,KAAK;IACd,CAAC,CAAC,OAAOA,KAAK,EAAE;MACdN,OAAO,CAACM,KAAK,CAAC,0BAA0B,EAAEA,KAAK,CAAC;MAChD,OAAO,KAAK;IACd;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;EACE,aAAaoH,mBAAmBA,CAACC,SAAS,EAAErF,SAAS,GAAG,IAAI,EAAE;IAC5D,IAAI;MACFtC,OAAO,CAACC,GAAG,CAAC,wBAAwB0H,SAAS,CAACnH,MAAM,QAAQ,CAAC;MAE7D,MAAM;QAAEmD,IAAI;QAAErD;MAAM,CAAC,GAAG,MAAMxB,QAAQ,CAAC8E,OAAO,CAC3CC,IAAI,CAAC,IAAI,CAACC,UAAU,CAAC,CACrB8C,MAAM,CAACe,SAAS,CAAC;MAEpB,IAAIrH,KAAK,EAAE;QAAA,IAAAsH,eAAA;QACT5H,OAAO,CAACM,KAAK,CAAC,wBAAwB,EAAEA,KAAK,CAAC;;QAE9C;QACA,IAAI,CAAAsH,eAAA,GAAAtH,KAAK,CAAC2D,OAAO,cAAA2D,eAAA,eAAbA,eAAA,CAAehI,QAAQ,CAAC,QAAQ,CAAC,IAAIU,KAAK,CAAC4F,MAAM,KAAK,GAAG,EAAE;UAC7DlG,OAAO,CAACC,GAAG,CAAC,uDAAuD,CAAC;UACpE,MAAM0F,OAAO,GAAG,MAAMzB,OAAO,CAAC0B,UAAU,CACtC+B,SAAS,CAAChG,GAAG,CAACkD,IAAI,IAAI,IAAI,CAAC6B,UAAU,CAAC7B,IAAI,EAAEvC,SAAS,CAAC,CACxD,CAAC;UAED,MAAMuD,UAAU,GAAGF,OAAO,CAACP,MAAM,CAACyC,CAAC,IAAIA,CAAC,CAAC3B,MAAM,KAAK,WAAW,IAAI2B,CAAC,CAAC1B,KAAK,KAAK,IAAI,CAAC,CAAC3F,MAAM;UAC3F,MAAMsF,MAAM,GAAG6B,SAAS,CAACvC,MAAM,CAAC,CAACP,IAAI,EAAEoB,KAAK,KAC1CN,OAAO,CAACM,KAAK,CAAC,CAACC,MAAM,KAAK,UAAU,IAAIP,OAAO,CAACM,KAAK,CAAC,CAACE,KAAK,KAAK,KACnE,CAAC;UAED,OAAO;YAAEN,UAAU;YAAEC;UAAO,CAAC;QAC/B;QAEA,OAAO;UAAED,UAAU,EAAE,CAAC;UAAEC,MAAM,EAAE6B;QAAU,CAAC;MAC7C;;MAEA;MACA;MACA;MACA3H,OAAO,CAACC,GAAG,CAAC,wBAAwB0H,SAAS,CAACnH,MAAM,qBAAqB,CAAC;MAE1E,OAAO;QACLqF,UAAU,EAAE8B,SAAS,CAACnH,MAAM;QAC5BsF,MAAM,EAAE;MACV,CAAC;IACH,CAAC,CAAC,OAAOxF,KAAK,EAAE;MACdN,OAAO,CAACM,KAAK,CAAC,mCAAmC,EAAEA,KAAK,CAAC;MACzD,OAAO;QAAEuF,UAAU,EAAE,CAAC;QAAEC,MAAM,EAAE6B;MAAU,CAAC;IAC7C;EACF;;EAEA;AACF;AACA;AACA;AACA;EACE,aAAaG,YAAYA,CAAClF,QAAQ,EAAE;IAClC,IAAI;MACF,MAAM;QAAEe,IAAI;QAAErD;MAAM,CAAC,GAAG,MAAMxB,QAAQ,CAAC8E,OAAO,CAC3CC,IAAI,CAAC,IAAI,CAACC,UAAU,CAAC,CACrB2D,QAAQ,CAAC7E,QAAQ,CAAC;MAErB,IAAItC,KAAK,EAAE;QACT,MAAMA,KAAK;MACb;MAEA,OAAOqD,IAAI;IACb,CAAC,CAAC,OAAOrD,KAAK,EAAE;MACdN,OAAO,CAACM,KAAK,CAAC,iBAAiB,EAAEA,KAAK,CAAC;MACvC,MAAMA,KAAK;IACb;EACF;;EAEA;AACF;AACA;AACA;AACA;EACE,aAAayH,SAASA,CAACC,UAAU,GAAG,EAAE,EAAE;IACtC,IAAI;MACF,MAAM;QAAErE,IAAI;QAAErD;MAAM,CAAC,GAAG,MAAMxB,QAAQ,CAAC8E,OAAO,CAC3CC,IAAI,CAAC,IAAI,CAACC,UAAU,CAAC,CACrBmE,IAAI,CAACD,UAAU,CAAC;MAEnB,IAAI1H,KAAK,EAAE;QACT,MAAMA,KAAK;MACb;MAEA,OAAOqD,IAAI,IAAI,EAAE;IACnB,CAAC,CAAC,OAAOrD,KAAK,EAAE;MACdN,OAAO,CAACM,KAAK,CAAC,mBAAmB,EAAEA,KAAK,CAAC;MACzC,MAAMA,KAAK;IACb;EACF;AACF;AAzmBE;AADInB,sBAAsB,CAEnB2E,UAAU,GAAG,8BAA8B;AAF9C3E,sBAAsB,CAGnB+I,WAAW,GAAGC,OAAO,CAACC,GAAG,CAACC,sBAAsB,IAAI,yBAAyB;AAHhFlJ,sBAAsB,CAInBiB,WAAW,GAAG,CAAC,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI;AAAE;AAJzCjB,sBAAsB,CAKnBY,YAAY,GAAG;AACpB;AACA,iBAAiB,EAAE,mBAAmB;AAEtC;AACA,YAAY,EAAE,WAAW,EAAE,WAAW,EAAE,WAAW,EAAE,YAAY,EACjE,WAAW,EAAE,YAAY,EAAE,eAAe;AAE1C;AACA,0BAA0B,EAAE,mBAAmB,EAAE,qBAAqB,EACtE,mEAAmE;AAEnE;AACA,kBAAkB,EAAE,oBAAoB,EAAE,yBAAyB,EACnE,aAAa,EAAE,iBAAiB,EAAE,eAAe,EAAE,mBAAmB,EACtE,iBAAiB,EAAE,mBAAmB,EAAE,eAAe,EAAE,aAAa;AAEtE;AACA,YAAY,EAAE,UAAU,EAAE,iBAAiB,EAAE,YAAY;AAEzD;AACA,iBAAiB,EAAE,8BAA8B,EAAE,mBAAmB,EACtE,8BAA8B,EAAE,qBAAqB,EAAE,iBAAiB,EAAE,mBAAmB;AAE7F;AACA,oBAAoB,EAAE,WAAW,EAAE,iBAAiB,EAAE,mBAAmB,EACzE,0BAA0B;AAAE;AAC5B,kBAAkB,EAAE,YAAY,EAAE,cAAc,EAAE,iBAAiB,EAAE,iBAAiB,EACtF,iBAAiB,EAAE,4BAA4B,EAAE,WAAW,EAAE,mBAAmB;AAEjF;AACA,EAAE;AAAE;AACJ,IAAI,CAAC;AAAA,CACN;AAtCGZ,sBAAsB,CAuCnBQ,iBAAiB,GAAG;AACzB;AACA,MAAM;AACN;AACA,MAAM,EAAE,OAAO,EAAE,MAAM,EAAE,MAAM,EAAE,OAAO,EAAE,MAAM,EAAE,OAAO,EAAE,MAAM,EAAE,MAAM;AACzE;AACA,MAAM,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO;AACjC;AACA,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,OAAO;AAC/B;AACA,MAAM,EAAE,MAAM;AACd;AACA,MAAM,EAAE,MAAM,EAAE,KAAK;AACrB;AACA,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,OAAO,EAAE,MAAM,EAAE,MAAM,EAAE,OAAO,EAAE,MAAM;AACxE;AACA,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,CAC/C;AAojBH,eAAeR,sBAAsB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}